<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Sea Farer — Modern Warfare Scope Hunt (UAV + Recoil)</title>
  <style>
    :root{
      --hud: rgba(235,240,255,0.92);
      --hud2: rgba(235,240,255,0.72);
      --warn: rgba(255,210,90,0.95);
    }

    html,body{height:100%; margin:0; overflow:hidden; background:#05060b; color:var(--hud);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      user-select:none; -webkit-user-select:none; touch-action:none;
    }
    #wrap{position:relative; width:100vw; height:100vh;}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}

    .mw-top{
      position:absolute; left:14px; top:12px;
      pointer-events:none;
      display:flex; flex-direction:column; gap:8px;
      width:min(380px, calc(100vw - 28px));
    }
    .mw-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 46px rgba(0,0,0,0.38);
    }
    .mw-title{
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; letter-spacing:0.6px; text-transform:uppercase;
      color: var(--hud2); font-weight:800;
      margin-bottom:6px;
    }
    .mw-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      font-size:12px;
      color: var(--hud2);
      line-height:1.35;
    }
    .mw-grid b{ color: var(--hud); font-weight:800; }

    .mw-bottom{
      position:absolute; left:14px; bottom:14px;
      pointer-events:none;
      display:flex; gap:10px; flex-wrap:wrap;
      width:min(520px, calc(100vw - 28px));
    }
    .pill{
      background: rgba(0,0,0,0.38);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:999px;
      padding:8px 12px;
      backdrop-filter: blur(10px);
      color: var(--hud2);
      font-size:12px;
      display:flex; gap:10px; align-items:center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
    }
    .pill b{ color: var(--hud); }

    .banner{
      position:absolute;
      left:50%; transform:translateX(-50%);
      bottom:84px;
      pointer-events:none;
      opacity:0;
      transition: opacity 160ms ease, transform 160ms ease;
      background: rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      padding:10px 14px;
      backdrop-filter: blur(12px);
      color: var(--hud);
      font-size:13px;
      letter-spacing:0.2px;
      box-shadow: 0 12px 46px rgba(0,0,0,0.45);
      white-space:nowrap;
    }
    .banner.show{
      opacity:1;
      transform:translateX(-50%) translateY(-4px);
    }
    .banner small{ color: var(--hud2); font-size:12px; margin-left:10px; }

    .tips{
      position:absolute; right:14px; top:12px; width:min(520px, calc(100vw - 28px));
      pointer-events:none;
      display:flex; flex-direction:column; gap:10px; align-items:flex-end;
    }
    .tip{
      background: rgba(0,0,0,0.44);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      font-size:12px;
      color: var(--hud2);
      max-width: 520px;
    }
    .tip b{ color: var(--warn); }

    .controls{
      position:absolute; right:14px; bottom:14px;
      pointer-events:auto;
    }
    .rowbtn{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      appearance:none; border:none; cursor:pointer;
      border-radius:12px; padding:10px 12px;
      background: rgba(255,255,255,0.10);
      color: var(--hud);
      border: 1px solid rgba(255,255,255,0.14);
      font-weight:800; letter-spacing:0.2px;
    }
    button:hover{ background: rgba(255,255,255,0.14); }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="mw-top">
    <div class="mw-card">
      <div class="mw-title">
        <span>Sea Farer — Modern Warfare</span>
        <span id="adsTxt">ADS: OFF</span>
      </div>
      <div class="mw-grid">
        <div>Round <b id="roundTxt">1</b></div>
        <div>Timer <b id="timerTxt">60.0s</b></div>
        <div>Objective <b id="objTxt">—</b></div>
        <div>Hint <b id="hintTxt">—</b></div>
        <div>Ammo <b id="ammoTxt">30 / 90</b></div>
        <div>Wind <b id="windTxt">0.0 kt</b></div>
        <div>Range <b id="rangeTxt">0 m</b></div>
        <div>Points <b id="pointsTxt">0</b></div>
      </div>
    </div>
  </div>

  <div class="mw-bottom">
    <div class="pill">Kills <b id="killsTxt">0</b> / Shots <b id="shotsTxt">0</b></div>
    <div class="pill">Streak <b id="streakTxt">0</b></div>
    <div class="pill">Targets left <b id="leftTxt">3</b></div>
  </div>

  <div class="banner" id="banner">Target Down <small id="bannerSub">+100</small></div>

  <div class="tips" id="tips"></div>

  <div class="controls">
    <div class="rowbtn">
      <button id="resetBtn">Reset</button>
      <button id="shuffleBtn">Shuffle</button>
      <button id="visionBtn">Vision: Normal</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  // UI
  const adsTxt = document.getElementById('adsTxt');
  const roundTxt = document.getElementById('roundTxt');
  const timerTxt = document.getElementById('timerTxt');
  const objTxt = document.getElementById('objTxt');
  const hintTxt = document.getElementById('hintTxt');
  const ammoTxt = document.getElementById('ammoTxt');
  const windTxt = document.getElementById('windTxt');
  const rangeTxt = document.getElementById('rangeTxt');
  const pointsTxt = document.getElementById('pointsTxt');

  const killsTxt = document.getElementById('killsTxt');
  const shotsTxt = document.getElementById('shotsTxt');
  const streakTxt = document.getElementById('streakTxt');
  const leftTxt = document.getElementById('leftTxt');

  const banner = document.getElementById('banner');
  const bannerSub = document.getElementById('bannerSub');
  const tipsEl = document.getElementById('tips');

  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const visionBtn = document.getElementById('visionBtn');

  // ===== MW FEEL CONFIG =====
  const WORLD_W = 2800;
  const WORLD_H = 1900;

  const NUM_CHAR = 95;
  const CHAR_SIZE = 15;

  // Hits / assist
  const HIT_RADIUS = 24;
  const AIM_ASSIST_RADIUS = 95;
  const AIM_ASSIST_STRENGTH = 0.16;
  const DANCE_RADIUS = 85;

  // Ballistics (mild)
  const MUZZLE_V = 980;
  const MAX_TOF  = 0.85;
  const WIND_KT_TO_DRIFT = 0.30;

  // Camera / ADS
  const CAM_FOLLOW = 0.16;
  const ZOOM_OFF = 1.0;
  const ZOOM_ON  = 3.4;
  const ZOOM_SPEED = 0.18;

  // Sway
  const SWAY_MAG = 1.35;
  const SWAY_SPEED = 0.0016;

  // Shot shake (visual)
  const SHAKE_ON_SHOT = 5.5;
  const SHAKE_DECAY = 0.86;

  // Ammo
  const MAG_SIZE = 30;
  const RESERVE_START = 90;
  const RELOAD_MS = 900;

  // Round system
  const TARGETS_PER_ROUND = 3;
  const ROUND_TIME_S = 60;

  // UAV streak
  const UAV_STREAK_REQ = 4;
  const UAV_DURATION_MS = 4200;      // few seconds, MW-ish
  const UAV_PING_EVERY_MS = 520;     // ping cadence
  const UAV_PING_FLASH_MS = 220;     // flash on screen
  const UAV_PING_RADIUS_PX = 28;     // on-screen ping size
  const UAV_OFFSCREEN_EDGE_PAD = 18; // how close to edge indicator sits

  // Recoil pattern (MW-ish)
  const RECOIL_PER_SHOT_Y = 10.0;   // px (screen-space)
  const RECOIL_PER_SHOT_X = 2.2;    // px (screen-space)
  const RECOIL_RANDOM_X = 0.9;      // px
  const RECOIL_ADS_MULT = 0.78;     // ADS recoil slightly reduced
  const RECOIL_BREATH_MULT = 0.70;  // holding breath steadier

  // Recoil recovery (springy return)
  const RECOIL_RETURN = 0.22;       // pull back toward 0
  const RECOIL_DAMP = 0.82;         // damp velocity

  // Vision
  const visionModes = ["Normal","Night Vision","Thermal"];
  let visionIndex = 0;

  // DPR resize
  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener('resize', resize);
  resize();

  // Helpers
  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const lerp=(a,b,t)=>a+(b-a)*t;

  // Tiny audio
  let audioCtx = null;
  function beep(freq=880, dur=0.05, type="square", gain=0.04){
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    }catch{}
  }

  function tip(html, ms=1800){
    const div = document.createElement('div');
    div.className='tip';
    div.innerHTML = html;
    tipsEl.appendChild(div);
    setTimeout(()=>{
      div.style.transition='opacity 260ms ease, transform 260ms ease';
      div.style.opacity='0';
      div.style.transform='translateY(-6px)';
      setTimeout(()=>div.remove(),320);
    }, ms);
  }

  function showBanner(text, sub="+100", ms=900){
    banner.textContent = text + " ";
    bannerSub.textContent = sub;
    banner.classList.add("show");
    setTimeout(()=>banner.classList.remove("show"), ms);
  }

  // Cursor
  const cursor = { x: W/2, y: H/2 };

  // Camera
  const cam = { x: WORLD_W/2, y: WORLD_H/2, shakeX:0, shakeY:0 };

  // ADS + zoom
  let scoped=false;
  let zoom=ZOOM_OFF;
  let zoomTarget=ZOOM_OFF;

  // Breath hold reduces sway & recoil
  let holdBreath=false;

  // Wind
  const wind = { base: rand(7, 14), dir: Math.random()*Math.PI*2 };
  let gust = { extra:0, until:0, active:false };
  function effectiveWind(){ return wind.base + (gust.active ? gust.extra : 0); }

  // Ammo/reload
  let mag = MAG_SIZE;
  let reserve = RESERVE_START;
  let reloading=false;
  let reloadUntil=0;

  // Score/stats
  let shots=0, kills=0, streak=0, points=0;

  // Round
  let round=1;
  let timeLeft=ROUND_TIME_S;
  let roundTargets=[];
  let currentTargetIndex=0;

  // UAV state
  let uavActiveUntil = 0;
  let uavNextPingAt = 0;
  let uavPingFlashUntil = 0;
  let uavAnnounceUntil = 0;
  let uavArmed = true; // can trigger again after streak hits requirement anew

  // Recoil state (screen-space offset applied to aim)
  const recoil = {
    x: 0, y: 0,
    vx: 0, vy: 0
  };

  // World content
  const ICONS = [
    { name:"Pika-ish", glyph:"⚡", hue: 52 },
    { name:"DBZ-ish",  glyph:"✦", hue: 40 },
    { name:"Fighter",  glyph:"✊", hue: 10 },
    { name:"Sponge-ish", glyph:"▦", hue: 58 },
    { name:"Alien", glyph:"⬡", hue: 190 },
    { name:"Bot", glyph:"⬢", hue: 210 },
    { name:"Star", glyph:"✶", hue: 300 },
    { name:"Skull", glyph:"☠", hue: 350 }
  ];

  let chars=[];
  function spawn(){
    chars=[];
    for(let i=0;i<NUM_CHAR;i++){
      const icon = ICONS[(Math.random()*ICONS.length)|0];
      chars.push({
        id:i,
        x: rand(80, WORLD_W-80),
        y: rand(80, WORLD_H-80),
        alive:true,
        icon,
        seed: Math.random()*9999,
        scale: rand(0.90, 1.25),
        vx: rand(-22, 22),
        vy: rand(-16, 16),
        dance: 0
      });
    }
  }

  const stars = new Array(980).fill(0).map(()=>({
    x: Math.random()*WORLD_W,
    y: Math.random()*WORLD_H,
    r: Math.random()*1.6 + 0.25,
    a: Math.random()*0.8 + 0.15
  }));

  // Transforms
  function worldToScreen(wx, wy){
    const sx = (wx - cam.x) * zoom + (W/(2*DPR));
    const sy = (wy - cam.y) * zoom + (H/(2*DPR));
    return { x: sx*DPR + cam.shakeX, y: sy*DPR + cam.shakeY };
  }
  function screenToWorld(sx, sy){
    const wx = ((sx - cam.shakeX)/DPR - (W/(2*DPR))) / zoom + cam.x;
    const wy = ((sy - cam.shakeY)/DPR - (H/(2*DPR))) / zoom + cam.y;
    return { x: wx, y: wy };
  }

  // Input
  function setCursorFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (('clientX' in e) ? e.clientX : e.touches[0].clientX) - rect.left;
    const y = (('clientY' in e) ? e.clientY : e.touches[0].clientY) - rect.top;
    cursor.x = x * DPR;
    cursor.y = y * DPR;
  }
  canvas.addEventListener('contextmenu', (e)=>e.preventDefault());

  // Desktop
  canvas.addEventListener('mousemove', (e)=>setCursorFromEvent(e), { passive:true });
  canvas.addEventListener('mousedown', (e)=>{
    setCursorFromEvent(e);
    if(e.button===2){ toggleADS(); return; }
    if(e.button===0){ shoot(); return; }
  }, { passive:true });

  // Mobile: long press ADS, tap shoot, two-finger tap reload
  let pressTimer=null;
  canvas.addEventListener('touchstart', (e)=>{
    setCursorFromEvent(e);
    if(e.touches && e.touches.length>=2){ reload(); return; }
    pressTimer = setTimeout(()=>{ toggleADS(); pressTimer=null; }, 300);
  }, { passive:false });
  canvas.addEventListener('touchmove', (e)=>setCursorFromEvent(e), { passive:false });
  canvas.addEventListener('touchend', ()=>{
    if(pressTimer){
      clearTimeout(pressTimer);
      pressTimer=null;
      shoot();
    }
  }, { passive:false });

  addEventListener('keydown', (e)=>{
    const k=e.key.toLowerCase();
    if(k==='r') reload();
    if(k==='n') cycleVision();
    if(k==='escape') resetRound();
    if(e.key==='Shift') holdBreath=true;
  });
  addEventListener('keyup', (e)=>{
    if(e.key==='Shift') holdBreath=false;
  });

  resetBtn.addEventListener('click', resetRound);
  shuffleBtn.addEventListener('click', ()=>{
    spawn(); buildRoundTargets();
    tip("Crowd shuffled. Targets updated.", 1400);
  });
  visionBtn.addEventListener('click', cycleVision);

  function toggleADS(){
    scoped=!scoped;
    zoomTarget=scoped ? ZOOM_ON : ZOOM_OFF;
    adsTxt.textContent = `ADS: ${scoped ? "ON" : "OFF"}`;
    beep(scoped ? 520 : 420, 0.05, "sine", 0.04);
  }

  function cycleVision(){
    visionIndex = (visionIndex+1) % visionModes.length;
    visionBtn.textContent = `Vision: ${visionModes[visionIndex]}`;
    tip(`Vision: <b>${visionModes[visionIndex]}</b>`, 1000);
  }

  // Targets per round
  function quant(v, step){ return Math.round(v/step)*step; }

  function buildRoundTargets(){
    const alive=chars.filter(c=>c.alive);
    roundTargets=[];
    currentTargetIndex=0;
    const pool=alive.slice();
    for(let i=0;i<TARGETS_PER_ROUND && pool.length;i++){
      const idx=(Math.random()*pool.length)|0;
      roundTargets.push(pool[idx].id);
      pool.splice(idx,1);
    }
    updateObjectiveUI();
  }

  function currentTargetId(){ return roundTargets[currentTargetIndex] ?? null; }

  function updateObjectiveUI(){
    const id=currentTargetId();
    const t = (id===null) ? null : chars.find(c=>c.id===id && c.alive);
    if(!t){
      objTxt.textContent="—";
      hintTxt.textContent="—";
      leftTxt.textContent="0";
      return;
    }
    objTxt.textContent = t.icon.name;
    hintTxt.textContent = `X:${quant(t.x, 100)} Y:${quant(t.y, 100)}`;
    leftTxt.textContent = String(roundTargets.length - currentTargetIndex);
  }

  function updateAmmoUI(){
    ammoTxt.textContent = `${mag} / ${reserve}`;
  }

  // Ballistics
  function calcTof(range){
    const t = range / MUZZLE_V;
    return clamp(t, 0.04, MAX_TOF);
  }
  function leadDotWorld(aimW, tof){
    const ws = effectiveWind();
    const drift = ws * tof * WIND_KT_TO_DRIFT;
    return { x: aimW.x + Math.cos(wind.dir)*drift, y: aimW.y + Math.sin(wind.dir)*drift };
  }

  // Aim assist (ADS only) + recoil offset (screen space) applied to aim
  function getAimedWorldWithAssist(){
    // Apply recoil as a screen-space offset opposite the user’s compensation:
    // if recoil kicks UP, we effectively move the aiming point UP, so the player must pull DOWN.
    const aimScreenX = cursor.x + recoil.x * DPR;
    const aimScreenY = cursor.y + recoil.y * DPR;

    const raw = screenToWorld(aimScreenX, aimScreenY);

    if(!scoped) return raw;

    let best=null, bestD=Infinity;
    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(raw.x, raw.y, c.x, c.y);
      if(d < AIM_ASSIST_RADIUS && d < bestD){ best=c; bestD=d; }
    }
    if(!best) return raw;

    const strengthBase = AIM_ASSIST_STRENGTH + (holdBreath ? 0.06 : 0.0);
    return { x: lerp(raw.x, best.x, strengthBase), y: lerp(raw.y, best.y, strengthBase) };
  }

  // Reload
  function reload(){
    if(reloading) return;
    if(mag >= MAG_SIZE){ beep(200,0.06,"square",0.04); return; }
    if(reserve <= 0){ tip("No reserve ammo.", 1000); beep(160,0.07,"square",0.04); return; }
    reloading = true;
    reloadUntil = performance.now() + RELOAD_MS;
    tip("Reloading…", 700);
    beep(280,0.05,"sine",0.04);
  }

  // Bullet visuals + hits
  const bullets=[];
  let hitMarkerUntil=0;

  // Recoil kick pattern
  let recoilStep = 0;
  function applyRecoilKick(){
    const adsMult = scoped ? RECOIL_ADS_MULT : 1.0;
    const breathMult = holdBreath ? RECOIL_BREATH_MULT : 1.0;

    // Pattern: slight horizontal drift that alternates, with a small random component
    const dir = (recoilStep % 6 < 3) ? 1 : -1;
    const drift = dir * RECOIL_PER_SHOT_X + (Math.random()*2-1)*RECOIL_RANDOM_X;

    // Vertical always climbs
    const up = RECOIL_PER_SHOT_Y;

    const kx = drift * adsMult * breathMult;
    const ky = -up * adsMult * breathMult; // negative y = up on screen

    // Add to velocity (impulse)
    recoil.vx += kx * 0.45;
    recoil.vy += ky * 0.55;

    recoilStep++;
  }

  function shoot(){
    if(reloading) return;

    if(mag <= 0){
      beep(120, 0.05, "square", 0.05);
      tip("Empty. Reload (R).", 900);
      return;
    }

    mag--;
    shots++;
    updateAmmoUI();

    // recoil + camera shake
    applyRecoilKick();
    cam.shakeX += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;
    cam.shakeY += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;

    const now = performance.now();
    const aimW = getAimedWorldWithAssist();

    const range = dist(aimW.x, aimW.y, cam.x, cam.y);
    const tof = calcTof(range);
    const impactW = leadDotWorld(aimW, tof);

    bullets.push({ t0: now, tof, aimW:{...aimW}, impactW, alive:true });

    // MW-ish gun pop (subtle)
    beep(920, 0.03, "square", 0.05);
    beep(240, 0.04, "sine", 0.03);
  }

  function activateUAV(now){
    uavActiveUntil = now + UAV_DURATION_MS;
    uavNextPingAt = now;              // immediate first ping
    uavPingFlashUntil = now + UAV_PING_FLASH_MS;
    uavAnnounceUntil = now + 1200;

    tip(`<b>UAV ONLINE</b> — objective pings incoming.`, 1400);
    beep(650, 0.08, "sine", 0.05);
    beep(980, 0.07, "sine", 0.04);
  }

  function resolveBullet(b){
    let best=null, bestD=Infinity;

    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(b.impactW.x, b.impactW.y, c.x, c.y);
      if(d < HIT_RADIUS && d < bestD){
        best=c; bestD=d;
      }
    }

    if(best){
      best.alive=false;
      kills++;
      streak++;

      // UAV trigger exactly at streak 4 (once per streak run)
      const now = performance.now();
      if(streak >= UAV_STREAK_REQ && uavArmed){
        activateUAV(now);
        uavArmed = false; // disarm until streak resets
      }

      const headshot = (b.impactW.y < best.y - 10);
      const base = 100;
      const hsBonus = headshot ? 75 : 0;
      const streakBonus = Math.min(80, streak*8);
      const earned = base + hsBonus + streakBonus;

      points += earned;

      const range = Math.round(dist(best.x, best.y, cam.x, cam.y));
      hitMarkerUntil = performance.now() + 140;

      showBanner(headshot ? "HEADSHOT" : "TARGET DOWN", `+${earned}  •  ${range}m`, 950);
      beep(1100, 0.05, "sine", 0.05);

      const tgtId=currentTargetId();
      if(tgtId !== null && best.id === tgtId){
        points += 150;
        tip(`Objective eliminated: <b>${best.icon.name}</b> (+150)`, 1300);
        currentTargetIndex++;
        if(currentTargetIndex >= roundTargets.length){
          tip(`<b>Round clear.</b>`, 1400);
          startNextRound();
        } else {
          updateObjectiveUI();
        }
      }
    } else {
      if(streak > 0) tip("Miss. Streak reset.", 950);
      streak = 0;
      uavArmed = true; // re-arm UAV for next streak run
      beep(180, 0.06, "square", 0.04);
    }
  }

  // Wind
  function updateWind(now){
    wind.dir += Math.sin(now*0.00012) * 0.0007;
    if(!gust.active && Math.random() < 0.0016){
      gust.active=true;
      gust.extra=rand(1.5,4.2);
      gust.until=now + rand(900,1800);
    }
    if(gust.active && now >= gust.until){
      gust.active=false; gust.extra=0;
    }
  }

  // Background
  function drawBackground(){
    ctx.clearRect(0,0,W,H);
    const g = ctx.createRadialGradient(W*0.34,H*0.28, 10, W*0.34,H*0.28, Math.max(W,H)*0.92);
    g.addColorStop(0, 'rgba(16,26,85,1)');
    g.addColorStop(0.48,'rgba(7,10,20,1)');
    g.addColorStop(1,'rgba(5,6,11,1)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(const s of stars){
      const p = worldToScreen(s.x, s.y);
      if(p.x<-40||p.y<-40||p.x>W+40||p.y>H+40) continue;
      ctx.globalAlpha = s.a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s.r*DPR, 0, Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.fill();
    }
    ctx.restore();

    // very subtle grid
    ctx.save();
    ctx.globalAlpha=0.05;
    ctx.strokeStyle='rgba(255,255,255,1)';
    ctx.lineWidth=1*DPR;
    const grid=160;
    const tl = screenToWorld(0,0);
    const br = screenToWorld(W,H);
    const startX = Math.floor(tl.x/grid)*grid;
    const endX = Math.ceil(br.x/grid)*grid;
    const startY = Math.floor(tl.y/grid)*grid;
    const endY = Math.ceil(br.y/grid)*grid;
    for(let x=startX;x<=endX;x+=grid){
      const a=worldToScreen(x,startY), b=worldToScreen(x,endY);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    for(let y=startY;y<=endY;y+=grid){
      const a=worldToScreen(startX,y), b=worldToScreen(endX,y);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();
  }

  // Characters
  function updateAndDrawChars(now, aimW){
    let lock=null, lockD=1e9;
    const tgtId=currentTargetId();

    for(const c of chars){
      if(!c.alive) continue;

      c.x += c.vx * 0.016;
      c.y += c.vy * 0.016;
      if(c.x<80||c.x>WORLD_W-80) c.vx*=-1;
      if(c.y<80||c.y>WORLD_H-80) c.vy*=-1;
      c.x=clamp(c.x,80,WORLD_W-80);
      c.y=clamp(c.y,80,WORLD_H-80);

      const d = dist(aimW.x, aimW.y, c.x, c.y);
      const wantDance = (scoped && d < DANCE_RADIUS) ? 1 : 0;
      c.dance += (wantDance - c.dance) * 0.20;

      const phase = (now*0.007 + c.seed) % (Math.PI*2);
      const wig = c.dance * 6.5;
      const dx = Math.sin(phase*3.0) * wig;
      const dy = Math.cos(phase*2.2) * wig;

      const px = c.x + dx;
      const py = c.y + dy;

      if(scoped && d < DANCE_RADIUS && d < lockD){
        lock=c; lockD=d;
      }

      const p = worldToScreen(px, py);
      const size = CHAR_SIZE * c.scale * DPR * (0.88 + 0.12*zoom);

      ctx.save();
      ctx.translate(p.x, p.y);

      const hue = c.icon.hue;
      ctx.shadowColor = `hsla(${hue}, 90%, 65%, 0.52)`;
      ctx.shadowBlur = 12 * DPR;

      ctx.beginPath();
      ctx.moveTo(0, -size*1.35);
      ctx.lineTo(size*1.25, 0);
      ctx.lineTo(0, size*1.35);
      ctx.lineTo(-size*1.25, 0);
      ctx.closePath();
      ctx.fillStyle = `hsla(${hue}, 85%, 55%, 0.95)`;
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.lineWidth = 1.2*DPR;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.stroke();

      ctx.fillStyle='rgba(255,255,255,0.90)';
      ctx.font = `${Math.max(12, 14*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(c.icon.glyph, 0, 0);

      if(c.dance > 0.25){
        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = 'rgba(120,255,190,0.70)';
        ctx.lineWidth = 1.4*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*2.0, -0.55, 0.55);
        ctx.stroke();
      }

      // objective ping only when not ADS (MW)
      if(tgtId !== null && c.id === tgtId){
        ctx.globalAlpha = scoped ? 0.0 : 0.22;
        ctx.strokeStyle = 'rgba(255,210,90,0.95)';
        ctx.lineWidth = 2.1*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*2.35, 0, Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
    }
    return lock;
  }

  // Bullets
  function drawBullets(now){
    for(const b of bullets){
      if(!b.alive) continue;
      const age = (now - b.t0)/1000;
      const t = clamp(age / b.tof, 0, 1);
      const x = b.aimW.x + (b.impactW.x - b.aimW.x) * t;
      const y = b.aimW.y + (b.impactW.y - b.aimW.y) * t;

      const p = worldToScreen(x,y);
      const a = worldToScreen(b.aimW.x, b.aimW.y);

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha=0.48;
      ctx.strokeStyle='rgba(255,255,255,1)';
      ctx.lineWidth=2.0*DPR;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(p.x,p.y); ctx.stroke();
      ctx.globalAlpha=0.85;
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.beginPath(); ctx.arc(p.x,p.y,2.5*DPR,0,Math.PI*2); ctx.fill();
      ctx.restore();

      if(age >= b.tof){
        b.alive=false;
        resolveBullet(b);
      }
    }
    for(let i=bullets.length-1;i>=0;i--) if(!bullets[i].alive) bullets.splice(i,1);
  }

  // Vision post
  function applyVisionPost(){
    const mode = visionModes[visionIndex];
    if(mode==="Normal") return;

    ctx.save();
    ctx.globalCompositeOperation='source-atop';

    if(mode==="Night Vision"){
      ctx.globalAlpha=0.20;
      ctx.fillStyle='rgb(40,255,120)';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=0.10;
      ctx.fillStyle='rgba(0,0,0,0.65)';
      for(let y=0;y<H;y+=6*DPR) ctx.fillRect(0,y,W,1*DPR);
    }

    if(mode==="Thermal"){
      ctx.globalAlpha=0.12;
      ctx.fillStyle='rgb(255,120,30)';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=0.18;
      const g=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.18,W/2,H/2,Math.min(W,H)*0.72);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,'rgba(0,0,0,0.65)');
      ctx.fillStyle=g;
      ctx.fillRect(0,0,W,H);
    }

    ctx.restore();
  }

  // UAV drawing (ping objective target)
  function drawUAV(now){
    if(now > uavActiveUntil) return;

    // ping cadence
    if(now >= uavNextPingAt){
      uavPingFlashUntil = now + UAV_PING_FLASH_MS;
      uavNextPingAt = now + UAV_PING_EVERY_MS;
      // tiny ping sound
      beep(740, 0.03, "sine", 0.03);
    }

    // objective target position
    const id = currentTargetId();
    const t = (id===null) ? null : chars.find(c=>c.id===id && c.alive);
    if(!t) return;

    const p = worldToScreen(t.x, t.y);

    const flash = now <= uavPingFlashUntil;

    // announce text near top-center briefly
    if(now <= uavAnnounceUntil){
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      const w = 170*DPR, h = 30*DPR;
      const x = W/2 - w/2, y = 16*DPR;
      roundRect(x, y, w, h, 14*DPR);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,210,90,0.95)';
      ctx.font = `${Math.max(12, 14*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText("UAV ONLINE", W/2, y + h/2);
      ctx.restore();
    }

    // draw ping (on-screen) or direction indicator (off-screen)
    const onScreen = (p.x >= 0 && p.x <= W && p.y >= 0 && p.y <= H);

    ctx.save();
    ctx.globalCompositeOperation='lighter';

    if(onScreen){
      const r = UAV_PING_RADIUS_PX * DPR;
      ctx.globalAlpha = flash ? 0.90 : 0.35;
      ctx.strokeStyle = 'rgba(255,210,90,1)';
      ctx.lineWidth = 2.2*DPR;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.stroke();

      ctx.globalAlpha = flash ? 0.60 : 0.18;
      ctx.fillStyle = 'rgba(255,210,90,1)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3.0*DPR, 0, Math.PI*2);
      ctx.fill();
    } else {
      // Direction indicator to target
      const cx = W/2, cy = H/2;
      const vx = p.x - cx;
      const vy = p.y - cy;
      const ang = Math.atan2(vy, vx);

      // place arrow on screen edge
      const pad = UAV_OFFSCREEN_EDGE_PAD * DPR;
      const ex = clamp(cx + Math.cos(ang)*(Math.min(cx,cy)-pad), pad, W-pad);
      const ey = clamp(cy + Math.sin(ang)*(Math.min(cx,cy)-pad), pad, H-pad);

      ctx.translate(ex, ey);
      ctx.rotate(ang);

      ctx.globalAlpha = flash ? 0.92 : 0.40;
      ctx.fillStyle = 'rgba(255,210,90,1)';
      ctx.beginPath();
      ctx.moveTo(18*DPR, 0);
      ctx.lineTo(-10*DPR, -8*DPR);
      ctx.lineTo(-6*DPR, 0);
      ctx.lineTo(-10*DPR, 8*DPR);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha = flash ? 0.55 : 0.20;
      ctx.strokeStyle = 'rgba(255,210,90,1)';
      ctx.lineWidth = 2*DPR;
      ctx.beginPath();
      ctx.arc(0,0, 14*DPR, -0.6, 0.6);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Overlay / reticle + hitmarker (uses recoil too)
  function drawOverlay(now, lock){
    const cx = cursor.x + recoil.x * DPR;
    const cy = cursor.y + recoil.y * DPR;

    if(!scoped){
      ctx.save();
      ctx.globalAlpha=0.75;
      ctx.strokeStyle='rgba(235,240,255,0.70)';
      ctx.lineWidth=2.0*DPR;
      const L=14*DPR, G=6*DPR;
      ctx.beginPath();
      ctx.moveTo(cx-L, cy); ctx.lineTo(cx-G, cy);
      ctx.moveTo(cx+G, cy); ctx.lineTo(cx+L, cy);
      ctx.moveTo(cx, cy-L); ctx.lineTo(cx, cy-G);
      ctx.moveTo(cx, cy+G); ctx.lineTo(cx, cy+L);
      ctx.stroke();
      ctx.restore();
      return;
    }

    const r = (210 / Math.sqrt(zoom)) * DPR;

    ctx.save();
    ctx.globalAlpha=0.76;
    ctx.fillStyle='rgba(0,0,0,1)';
    ctx.fillRect(0,0,W,H);

    ctx.globalCompositeOperation='destination-out';
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation='source-over';

    ctx.globalAlpha=1;
    ctx.lineWidth=3*DPR;
    ctx.strokeStyle='rgba(255,255,255,0.20)';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

    ctx.save();
    ctx.translate(cx,cy);
    ctx.strokeStyle = lock ? 'rgba(120,255,190,0.90)' : 'rgba(235,240,255,0.78)';
    ctx.lineWidth = 1.8*DPR;
    const L = r - 18*DPR;
    const G = 16*DPR;
    ctx.beginPath();
    ctx.moveTo(-L,0); ctx.lineTo(-G,0);
    ctx.moveTo(G,0);  ctx.lineTo(L,0);
    ctx.moveTo(0,-L); ctx.lineTo(0,-G);
    ctx.moveTo(0,G);  ctx.lineTo(0,L);
    ctx.stroke();

    ctx.fillStyle = lock ? 'rgba(120,255,190,0.98)' : 'rgba(235,240,255,0.88)';
    ctx.beginPath(); ctx.arc(0,0,2.2*DPR,0,Math.PI*2); ctx.fill();

    if(performance.now() <= hitMarkerUntil){
      ctx.strokeStyle='rgba(255,255,255,0.96)';
      ctx.lineWidth=2.3*DPR;
      const s=10*DPR;
      ctx.beginPath();
      ctx.moveTo(-s,-s); ctx.lineTo(s,s);
      ctx.moveTo(s,-s);  ctx.lineTo(-s,s);
      ctx.stroke();
    }

    ctx.restore();

    ctx.globalAlpha=0.10;
    ctx.fillStyle='rgba(255,255,255,1)';
    ctx.beginPath();
    ctx.arc(cx-r*0.22, cy-r*0.22, r*0.42, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Round control
  function startNextRound(){
    round++;
    roundTxt.textContent = String(round);
    timeLeft = ROUND_TIME_S;

    reserve = Math.min(180, reserve + 30);
    mag = MAG_SIZE;
    reloading=false;

    if(chars.filter(c=>c.alive).length < 28) spawn();
    else for(const c of chars) if(Math.random() < 0.28) c.alive = true;

    buildRoundTargets();
    updateAmmoUI();

    tip(`<b>Round ${round}</b> — new objectives.`, 1300);
  }

  function resetRound(){
    round=1;
    timeLeft=ROUND_TIME_S;

    shots=0; kills=0; streak=0; points=0;
    mag=MAG_SIZE; reserve=RESERVE_START;
    reloading=false;

    wind.base = rand(7, 14);
    wind.dir = Math.random()*Math.PI*2;
    gust.active=false; gust.extra=0;

    scoped=false;
    zoom=ZOOM_OFF; zoomTarget=ZOOM_OFF;

    bullets.length=0;

    // recoil reset
    recoil.x=0; recoil.y=0; recoil.vx=0; recoil.vy=0;
    recoilStep=0;

    // UAV reset
    uavActiveUntil=0; uavNextPingAt=0; uavPingFlashUntil=0; uavAnnounceUntil=0;
    uavArmed=true;

    spawn();
    buildRoundTargets();
    updateAmmoUI();

    adsTxt.textContent="ADS: OFF";
    roundTxt.textContent="1";

    tip("Reset.", 900);
  }

  // MAIN LOOP
  let last = performance.now();
  function tick(now){
    const dt = Math.min(40, now-last);
    last = now;

    // finish reload
    if(reloading && now >= reloadUntil){
      const need = MAG_SIZE - mag;
      const take = Math.min(need, reserve);
      mag += take;
      reserve -= take;
      reloading=false;
      updateAmmoUI();
      beep(520, 0.05, "sine", 0.04);
      tip("Reload complete.", 900);
    }

    // timer
    timeLeft -= dt/1000;
    if(timeLeft <= 0){
      tip(`<b>Time.</b> Next round.`, 1200);
      streak=0;
      uavArmed=true;
      startNextRound();
    }
    timerTxt.textContent = `${Math.max(0,timeLeft).toFixed(1)}s`;

    // wind
    updateWind(now);
    windTxt.textContent = `${effectiveWind().toFixed(1)} kt`;

    // smooth zoom
    zoom += (zoomTarget - zoom) * ZOOM_SPEED;

    // recoil recovery (spring)
    // pull recoil back toward 0, with damped velocity
    const rx = recoil.x;
    const ry = recoil.y;
    recoil.vx += (-rx) * RECOIL_RETURN;
    recoil.vy += (-ry) * RECOIL_RETURN;

    recoil.vx *= RECOIL_DAMP;
    recoil.vy *= RECOIL_DAMP;

    recoil.x += recoil.vx * (dt/16.67);
    recoil.y += recoil.vy * (dt/16.67);

    // clamp recoil so it doesn't fly off
    recoil.x = clamp(recoil.x, -40, 40);
    recoil.y = clamp(recoil.y, -90, 40);

    // aim (assist + recoil is already applied inside getAimedWorldWithAssist)
    const aimW = getAimedWorldWithAssist();

    // MW sway (reduced when holding breath)
    const swayScale = holdBreath ? 0.35 : 1.0;
    const swayX = Math.sin(now*SWAY_SPEED) * SWAY_MAG * swayScale;
    const swayY = Math.cos(now*SWAY_SPEED*0.9) * SWAY_MAG * swayScale;
    aimW.x += swayX;
    aimW.y += swayY;

    // camera follow
    cam.x += (aimW.x - cam.x) * CAM_FOLLOW;
    cam.y += (aimW.y - cam.y) * CAM_FOLLOW;
    cam.x = clamp(cam.x, 200, WORLD_W-200);
    cam.y = clamp(cam.y, 200, WORLD_H-200);

    // shake decay
    cam.shakeX *= SHAKE_DECAY;
    cam.shakeY *= SHAKE_DECAY;

    // draw
    drawBackground();
    const lock = updateAndDrawChars(now, aimW);
    drawBullets(now);
    applyVisionPost();
    drawUAV(now);
    drawOverlay(now, lock);

    // range
    rangeTxt.textContent = `${Math.round(dist(aimW.x, aimW.y, cam.x, cam.y))} m`;

    // UI
    pointsTxt.textContent = String(points);
    killsTxt.textContent = String(kills);
    shotsTxt.textContent = String(shots);
    streakTxt.textContent = String(streak);
    leftTxt.textContent = String(Math.max(0, roundTargets.length - currentTargetIndex));
    updateObjectiveUI();

    requestAnimationFrame(tick);
  }

  // Init
  function init(){
    spawn();
    buildRoundTargets();
    updateAmmoUI();
    tip(`MW controls: <b>Right-click ADS</b>, <b>Left-click shoot</b>, <b>R reload</b>, <b>Shift hold breath</b>.`, 2600);
    tip(`Streak <b>${UAV_STREAK_REQ}</b>: <b>UAV ONLINE</b> (objective pings).`, 2200);
    requestAnimationFrame(tick);
  }

  init();
})();
</script>
</body>
</html>
