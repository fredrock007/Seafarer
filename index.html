<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>Sea Farer — Tilt Scope Hunt (Mobile MW)</title>
  <style>
    :root{
      --hud: rgba(235,240,255,0.92);
      --hud2: rgba(235,240,255,0.72);
      --warn: rgba(255,210,90,0.95);
      --ok: rgba(120,255,190,0.95);
    }

    html,body{
      height:100%; margin:0; overflow:hidden; background:#05060b; color:var(--hud);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      user-select:none; -webkit-user-select:none; touch-action:none;
    }
    #wrap{position:relative; width:100vw; height:100vh;}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}

    .mw-top{
      position:absolute; left:14px; top:12px;
      pointer-events:none;
      display:flex; flex-direction:column; gap:8px;
      width:min(380px, calc(100vw - 28px));
    }
    .mw-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 46px rgba(0,0,0,0.38);
    }
    .mw-title{
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; letter-spacing:0.6px; text-transform:uppercase;
      color: var(--hud2); font-weight:800;
      margin-bottom:6px;
    }
    .mw-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      font-size:12px;
      color: var(--hud2);
      line-height:1.35;
    }
    .mw-grid b{ color: var(--hud); font-weight:800; }

    .mw-bottom{
      position:absolute; left:14px; bottom:14px;
      pointer-events:none;
      display:flex; gap:10px; flex-wrap:wrap;
      width:min(560px, calc(100vw - 28px));
    }
    .pill{
      background: rgba(0,0,0,0.38);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:999px;
      padding:8px 12px;
      backdrop-filter: blur(10px);
      color: var(--hud2);
      font-size:12px;
      display:flex; gap:10px; align-items:center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
    }
    .pill b{ color: var(--hud); }

    .banner{
      position:absolute;
      left:50%; transform:translateX(-50%);
      bottom:106px;
      pointer-events:none;
      opacity:0;
      transition: opacity 160ms ease, transform 160ms ease;
      background: rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      padding:10px 14px;
      backdrop-filter: blur(12px);
      color: var(--hud);
      font-size:13px;
      letter-spacing:0.2px;
      box-shadow: 0 12px 46px rgba(0,0,0,0.45);
      white-space:nowrap;
    }
    .banner.show{ opacity:1; transform:translateX(-50%) translateY(-4px); }
    .banner small{ color: var(--hud2); font-size:12px; margin-left:10px; }

    /* Floating controls */
    .shootBtn{
      position:absolute;
      right:16px;
      bottom:16px;
      width:74px;
      height:74px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.18), rgba(255,255,255,0.08));
      backdrop-filter: blur(10px);
      box-shadow: 0 16px 60px rgba(0,0,0,0.55);
      display:flex; align-items:center; justify-content:center;
      color:var(--hud);
      font-weight:900;
      letter-spacing:0.4px;
      cursor:pointer;
      touch-action:none;
    }
    .shootBtn:active{ transform: scale(0.98); }

    .permWrap{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);
    }
    .permCard{
      width:min(520px, calc(100vw - 28px));
      background: rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:18px;
      padding:16px;
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
    }
    .permCard h3{
      margin:0 0 10px 0;
      font-size:14px;
      text-transform:uppercase;
      letter-spacing:0.7px;
      color:var(--hud);
    }
    .permCard p{
      margin:0 0 12px 0;
      color:var(--hud2);
      font-size:13px;
      line-height:1.35;
    }
    .permRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .btn{
      appearance:none; border:none; cursor:pointer;
      border-radius:14px; padding:11px 12px;
      background: rgba(255,255,255,0.10);
      color: var(--hud);
      border: 1px solid rgba(255,255,255,0.14);
      font-weight:900;
      letter-spacing:0.2px;
    }
    .btn.ok{ border-color: rgba(120,255,190,0.35); }
    .btn.warn{ border-color: rgba(255,210,90,0.35); }
    .mini{
      margin-top:10px;
      font-size:12px;
      color:var(--hud2);
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="mw-top">
    <div class="mw-card">
      <div class="mw-title">
        <span>Sea Farer — Tilt Scope</span>
        <span id="modeTxt">MODE: MOBILE</span>
      </div>
      <div class="mw-grid">
        <div>Round <b id="roundTxt">1</b></div>
        <div>Timer <b id="timerTxt">60.0s</b></div>
        <div>Objective <b id="objTxt">—</b></div>
        <div>Hint <b id="hintTxt">—</b></div>
        <div>Ammo <b id="ammoTxt">30 / 90</b></div>
        <div>Wind <b id="windTxt">0.0 kt</b></div>
        <div>Zoom <b id="zoomTxt">3.4x</b></div>
        <div>Points <b id="pointsTxt">0</b></div>
      </div>
    </div>
  </div>

  <div class="mw-bottom">
    <div class="pill">Kills <b id="killsTxt">0</b> / Shots <b id="shotsTxt">0</b></div>
    <div class="pill">Streak <b id="streakTxt">0</b> (UAV@4)</div>
    <div class="pill">Targets left <b id="leftTxt">3</b></div>
  </div>

  <div class="banner" id="banner">Target Down <small id="bannerSub">+100</small></div>

  <button class="shootBtn" id="shootBtn" aria-label="Shoot">FIRE</button>

  <div class="permWrap" id="permWrap" style="display:none;">
    <div class="permCard">
      <h3>Enable tilt controls</h3>
      <p>
        This mode uses your phone’s motion sensors to aim the scope.
        Tap “Enable Tilt” to grant motion permission (needed on iPhone/iPad).
      </p>
      <div class="permRow">
        <button class="btn ok" id="enableTiltBtn">Enable Tilt</button>
        <button class="btn warn" id="noTiltBtn">Continue Without Tilt</button>
      </div>
      <div class="mini">
        Controls: tilt to aim • pinch to zoom • tap FIRE to shoot • two-finger tap to reload.
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  // UI
  const modeTxt = document.getElementById('modeTxt');
  const roundTxt = document.getElementById('roundTxt');
  const timerTxt = document.getElementById('timerTxt');
  const objTxt = document.getElementById('objTxt');
  const hintTxt = document.getElementById('hintTxt');
  const ammoTxt = document.getElementById('ammoTxt');
  const windTxt = document.getElementById('windTxt');
  const zoomTxt = document.getElementById('zoomTxt');
  const pointsTxt = document.getElementById('pointsTxt');

  const killsTxt = document.getElementById('killsTxt');
  const shotsTxt = document.getElementById('shotsTxt');
  const streakTxt = document.getElementById('streakTxt');
  const leftTxt = document.getElementById('leftTxt');

  const banner = document.getElementById('banner');
  const bannerSub = document.getElementById('bannerSub');

  const shootBtn = document.getElementById('shootBtn');

  const permWrap = document.getElementById('permWrap');
  const enableTiltBtn = document.getElementById('enableTiltBtn');
  const noTiltBtn = document.getElementById('noTiltBtn');

  // ===== CONFIG =====
  const WORLD_W = 2800;
  const WORLD_H = 1900;

  const NUM_CHAR = 95;
  const CHAR_SIZE = 15;

  // Hits / assist (mobile needs it slightly friendlier)
  const HIT_RADIUS = 26;
  const AIM_ASSIST_RADIUS = 120;
  const AIM_ASSIST_STRENGTH = 0.18;
  const DANCE_RADIUS = 95;

  // Ballistics
  const MUZZLE_V = 980;
  const MAX_TOF  = 0.85;
  const WIND_KT_TO_DRIFT = 0.30;

  // Camera / zoom
  const CAM_FOLLOW = 0.18;

  // IMPORTANT: on mobile scope is always ON (zoom ranges)
  const ZOOM_MIN = 1.8;
  const ZOOM_MAX = 6.0;
  const ZOOM_START = 3.4;
  const ZOOM_SPEED = 0.22;

  // Shot shake
  const SHAKE_ON_SHOT = 5.8;
  const SHAKE_DECAY = 0.86;

  // Ammo
  const MAG_SIZE = 30;
  const RESERVE_START = 90;
  const RELOAD_MS = 900;

  // Round system
  const TARGETS_PER_ROUND = 3;
  const ROUND_TIME_S = 60;

  // UAV
  const UAV_STREAK_REQ = 4;
  const UAV_DURATION_MS = 4200;
  const UAV_PING_EVERY_MS = 520;
  const UAV_PING_FLASH_MS = 220;
  const UAV_PING_RADIUS_PX = 28;
  const UAV_OFFSCREEN_EDGE_PAD = 18;

  // Recoil pattern (mobile: moderate)
  const RECOIL_PER_SHOT_Y = 9.0;
  const RECOIL_PER_SHOT_X = 2.0;
  const RECOIL_RANDOM_X = 0.9;
  const RECOIL_RETURN = 0.22;
  const RECOIL_DAMP = 0.82;

  // Tilt sensitivity (tweak these to taste)
  const TILT_SENS_X = 0.95;   // gamma sensitivity
  const TILT_SENS_Y = 0.95;   // beta sensitivity
  const TILT_SMOOTH = 0.14;   // smoothing of tilt input
  const TILT_DEADZONE = 1.2;  // degrees

  // DPR resize
  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener('resize', resize);
  resize();

  // Helpers
  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const lerp=(a,b,t)=>a+(b-a)*t;

  // ===== Audio (Zoom ticks + gunshot) =====
  let audioCtx=null;
  function ensureAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function clickTick(freq=520, dur=0.03, gain=0.05){
    try{
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    }catch{}
  }

  // A deeper “gun pop” using noise + sine thump (still lightweight)
  function gunShot(){
    try{
      ensureAudio();
      const t = audioCtx.currentTime;

      // Thump
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(140, t);
      osc.frequency.exponentialRampToValueAtTime(70, t+0.06);
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.22, t+0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t+0.10);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(t); osc.stop(t+0.11);

      // Noise “crack”
      const bufferSize = Math.floor(audioCtx.sampleRate * 0.06);
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * (1 - i/bufferSize);

      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;

      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.0001, t);
      ng.gain.exponentialRampToValueAtTime(0.16, t+0.005);
      ng.gain.exponentialRampToValueAtTime(0.0001, t+0.06);

      noise.connect(ng); ng.connect(audioCtx.destination);
      noise.start(t); noise.stop(t+0.07);
    }catch{}
  }

  function beep(freq=880, dur=0.05, type="sine", gain=0.04){
    try{
      ensureAudio();
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t);
      o.stop(t + dur);
    }catch{}
  }

  function showBanner(text, sub="+100", ms=900){
    banner.textContent = text + " ";
    bannerSub.textContent = sub;
    banner.classList.add("show");
    setTimeout(()=>banner.classList.remove("show"), ms);
  }

  // ===== Mobile-centric input model =====
  // We keep the crosshair centered and tilt moves the camera aim point.
  const cross = { x: 0, y: 0 }; // screen center each frame
  function updateCrossCenter(){
    cross.x = W/2;
    cross.y = H/2;
  }
  updateCrossCenter();

  // Tilt reading
  const tilt = { beta:0, gamma:0, sb:0, sg:0, enabled:false };
  function deadzone(v){
    return (Math.abs(v) < TILT_DEADZONE) ? 0 : v - Math.sign(v)*TILT_DEADZONE;
  }

  // Pinch-to-zoom state
  let pinching=false;
  let pinchStartDist=0;
  let pinchStartZoom=ZOOM_START;
  let lastZoomTickAt=0;

  // ===== World / Camera =====
  const cam = { x: WORLD_W/2, y: WORLD_H/2, shakeX:0, shakeY:0 };
  let zoom = ZOOM_START;
  let zoomTarget = ZOOM_START;

  // Wind
  const wind = { base: rand(7, 14), dir: Math.random()*Math.PI*2 };
  let gust = { extra:0, until:0, active:false };
  function effectiveWind(){ return wind.base + (gust.active ? gust.extra : 0); }

  // Ammo
  let mag = MAG_SIZE;
  let reserve = RESERVE_START;
  let reloading=false;
  let reloadUntil=0;

  // Stats
  let shots=0, kills=0, streak=0, points=0;

  // Round
  let round=1;
  let timeLeft=ROUND_TIME_S;
  let roundTargets=[];
  let currentTargetIndex=0;

  // UAV
  let uavActiveUntil=0, uavNextPingAt=0, uavPingFlashUntil=0, uavAnnounceUntil=0;
  let uavArmed=true;

  // Recoil (screen-space)
  const recoil = { x:0, y:0, vx:0, vy:0 };
  let recoilStep=0;

  // Icons/Characters
  const ICONS = [
    { name:"Pika-ish", glyph:"⚡", hue: 52 },
    { name:"DBZ-ish",  glyph:"✦", hue: 40 },
    { name:"Fighter",  glyph:"✊", hue: 10 },
    { name:"Sponge-ish", glyph:"▦", hue: 58 },
    { name:"Alien", glyph:"⬡", hue: 190 },
    { name:"Bot", glyph:"⬢", hue: 210 },
    { name:"Star", glyph:"✶", hue: 300 },
    { name:"Skull", glyph:"☠", hue: 350 }
  ];

  let chars=[];
  function spawn(){
    chars=[];
    for(let i=0;i<NUM_CHAR;i++){
      const icon = ICONS[(Math.random()*ICONS.length)|0];
      chars.push({
        id:i,
        x: rand(80, WORLD_W-80),
        y: rand(80, WORLD_H-80),
        alive:true,
        icon,
        seed: Math.random()*9999,
        scale: rand(0.90, 1.25),
        vx: rand(-22, 22),
        vy: rand(-16, 16),
        dance: 0
      });
    }
  }

  const stars = new Array(980).fill(0).map(()=>({
    x: Math.random()*WORLD_W,
    y: Math.random()*WORLD_H,
    r: Math.random()*1.6 + 0.25,
    a: Math.random()*0.8 + 0.15
  }));

  // Transforms
  function worldToScreen(wx, wy){
    const sx = (wx - cam.x) * zoom + (W/(2*DPR));
    const sy = (wy - cam.y) * zoom + (H/(2*DPR));
    return { x: sx*DPR + cam.shakeX, y: sy*DPR + cam.shakeY };
  }
  function screenToWorld(sx, sy){
    const wx = ((sx - cam.shakeX)/DPR - (W/(2*DPR))) / zoom + cam.x;
    const wy = ((sy - cam.shakeY)/DPR - (H/(2*DPR))) / zoom + cam.y;
    return { x: wx, y: wy };
  }

  // ===== Targets / Objective =====
  function quant(v, step){ return Math.round(v/step)*step; }
  function currentTargetId(){ return roundTargets[currentTargetIndex] ?? null; }

  function buildRoundTargets(){
    const alive=chars.filter(c=>c.alive);
    roundTargets=[];
    currentTargetIndex=0;
    const pool=alive.slice();
    for(let i=0;i<TARGETS_PER_ROUND && pool.length;i++){
      const idx=(Math.random()*pool.length)|0;
      roundTargets.push(pool[idx].id);
      pool.splice(idx,1);
    }
    updateObjectiveUI();
  }

  function updateObjectiveUI(){
    const id=currentTargetId();
    const t = (id===null) ? null : chars.find(c=>c.id===id && c.alive);
    if(!t){
      objTxt.textContent="—";
      hintTxt.textContent="—";
      leftTxt.textContent="0";
      return;
    }
    objTxt.textContent = t.icon.name;
    hintTxt.textContent = `X:${quant(t.x, 100)} Y:${quant(t.y, 100)}`;
    leftTxt.textContent = String(roundTargets.length - currentTargetIndex);
  }

  function updateAmmoUI(){ ammoTxt.textContent = `${mag} / ${reserve}`; }

  // ===== Ballistics / Aim assist =====
  function calcTof(range){
    const t = range / MUZZLE_V;
    return clamp(t, 0.04, MAX_TOF);
  }
  function leadDotWorld(aimW, tof){
    const ws = effectiveWind();
    const drift = ws * tof * WIND_KT_TO_DRIFT;
    return { x: aimW.x + Math.cos(wind.dir)*drift, y: aimW.y + Math.sin(wind.dir)*drift };
  }

  // Our "aim point" is the centered crosshair (plus recoil)
  function getAimWorld(){
    const aimScreenX = cross.x + recoil.x * DPR;
    const aimScreenY = cross.y + recoil.y * DPR;
    const raw = screenToWorld(aimScreenX, aimScreenY);

    // assist (always, but subtle)
    let best=null, bestD=Infinity;
    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(raw.x, raw.y, c.x, c.y);
      if(d < AIM_ASSIST_RADIUS && d < bestD){ best=c; bestD=d; }
    }
    if(!best) return raw;

    return { x: lerp(raw.x, best.x, AIM_ASSIST_STRENGTH), y: lerp(raw.y, best.y, AIM_ASSIST_STRENGTH) };
  }

  // ===== Reload / Shoot =====
  function reload(){
    if(reloading) return;
    if(mag >= MAG_SIZE){ beep(200,0.06,"square",0.04); return; }
    if(reserve <= 0){ beep(160,0.07,"square",0.04); return; }
    reloading = true;
    reloadUntil = performance.now() + RELOAD_MS;
    beep(280, 0.05, "sine", 0.04);
  }

  const bullets=[];
  let hitMarkerUntil=0;

  function applyRecoilKick(){
    const dir = (recoilStep % 6 < 3) ? 1 : -1;
    const drift = dir * RECOIL_PER_SHOT_X + (Math.random()*2-1)*RECOIL_RANDOM_X;
    const up = RECOIL_PER_SHOT_Y;

    recoil.vx += drift * 0.45;
    recoil.vy += (-up) * 0.55;

    recoilStep++;
  }

  function activateUAV(now){
    uavActiveUntil = now + UAV_DURATION_MS;
    uavNextPingAt = now;
    uavPingFlashUntil = now + UAV_PING_FLASH_MS;
    uavAnnounceUntil = now + 1200;
    beep(650, 0.08, "sine", 0.05);
    beep(980, 0.07, "sine", 0.04);
  }

  function shoot(){
    if(reloading) return;
    if(mag <= 0){ beep(120,0.06,"square",0.05); return; }

    ensureAudio(); // ensures sounds work right after user interaction

    mag--;
    shots++;
    updateAmmoUI();

    applyRecoilKick();
    cam.shakeX += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;
    cam.shakeY += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;

    const now = performance.now();
    const aimW = getAimWorld();

    const range = dist(aimW.x, aimW.y, cam.x, cam.y);
    const tof = calcTof(range);
    const impactW = leadDotWorld(aimW, tof);

    bullets.push({ t0: now, tof, aimW:{...aimW}, impactW, alive:true });

    gunShot();
  }

  function resolveBullet(b){
    let best=null, bestD=Infinity;
    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(b.impactW.x, b.impactW.y, c.x, c.y);
      if(d < HIT_RADIUS && d < bestD){ best=c; bestD=d; }
    }

    if(best){
      best.alive=false;
      kills++;
      streak++;

      const now = performance.now();
      if(streak >= UAV_STREAK_REQ && uavArmed){
        activateUAV(now);
        uavArmed=false;
      }

      const headshot = (b.impactW.y < best.y - 10);
      const earned = 100 + (headshot ? 75 : 0) + Math.min(80, streak*8);
      points += earned;
      hitMarkerUntil = performance.now() + 140;

      const r = Math.round(dist(best.x, best.y, cam.x, cam.y));
      showBanner(headshot ? "HEADSHOT" : "TARGET DOWN", `+${earned}  •  ${r}m`, 950);
      beep(1100, 0.05, "sine", 0.05);

      const tgtId=currentTargetId();
      if(tgtId !== null && best.id === tgtId){
        points += 150;
        currentTargetIndex++;
        if(currentTargetIndex >= roundTargets.length){
          startNextRound();
        } else {
          updateObjectiveUI();
        }
      }
    } else {
      streak=0;
      uavArmed=true;
      beep(180, 0.06, "square", 0.04);
    }
  }

  // ===== Visuals =====
  function drawBackground(){
    ctx.clearRect(0,0,W,H);
    const g = ctx.createRadialGradient(W*0.34,H*0.28, 10, W*0.34,H*0.28, Math.max(W,H)*0.92);
    g.addColorStop(0, 'rgba(16,26,85,1)');
    g.addColorStop(0.48,'rgba(7,10,20,1)');
    g.addColorStop(1,'rgba(5,6,11,1)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(const s of stars){
      const p = worldToScreen(s.x, s.y);
      if(p.x<-40||p.y<-40||p.x>W+40||p.y>H+40) continue;
      ctx.globalAlpha = s.a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s.r*DPR, 0, Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.fill();
    }
    ctx.restore();
  }

  function updateAndDrawChars(now, aimW){
    let lock=null, lockD=1e9;
    const tgtId=currentTargetId();

    for(const c of chars){
      if(!c.alive) continue;

      c.x += c.vx * 0.016;
      c.y += c.vy * 0.016;
      if(c.x<80||c.x>WORLD_W-80) c.vx*=-1;
      if(c.y<80||c.y>WORLD_H-80) c.vy*=-1;
      c.x=clamp(c.x,80,WORLD_W-80);
      c.y=clamp(c.y,80,WORLD_H-80);

      const d = dist(aimW.x, aimW.y, c.x, c.y);
      const wantDance = (d < DANCE_RADIUS) ? 1 : 0;
      c.dance += (wantDance - c.dance) * 0.20;

      const phase = (now*0.007 + c.seed) % (Math.PI*2);
      const wig = c.dance * 6.5;
      const px = c.x + Math.sin(phase*3.0)*wig;
      const py = c.y + Math.cos(phase*2.2)*wig;

      if(d < DANCE_RADIUS && d < lockD){ lock=c; lockD=d; }

      const p = worldToScreen(px, py);
      const size = CHAR_SIZE * c.scale * DPR * (0.88 + 0.12*zoom);

      ctx.save();
      ctx.translate(p.x, p.y);

      const hue = c.icon.hue;
      ctx.shadowColor = `hsla(${hue}, 90%, 65%, 0.52)`;
      ctx.shadowBlur = 12 * DPR;

      ctx.beginPath();
      ctx.moveTo(0, -size*1.35);
      ctx.lineTo(size*1.25, 0);
      ctx.lineTo(0, size*1.35);
      ctx.lineTo(-size*1.25, 0);
      ctx.closePath();
      ctx.fillStyle = `hsla(${hue}, 85%, 55%, 0.95)`;
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.lineWidth = 1.2*DPR;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.stroke();

      ctx.fillStyle='rgba(255,255,255,0.90)';
      ctx.font = `${Math.max(12, 14*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(c.icon.glyph, 0, 0);

      if(c.dance > 0.25){
        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = 'rgba(120,255,190,0.70)';
        ctx.lineWidth = 1.4*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*2.0, -0.55, 0.55);
        ctx.stroke();
      }

      // tiny objective cue only when UAV ping flashes (otherwise MW clean)
      if(tgtId !== null && c.id === tgtId && performance.now() <= uavPingFlashUntil && performance.now() <= uavActiveUntil){
        ctx.globalAlpha = 0.60;
        ctx.strokeStyle = 'rgba(255,210,90,0.95)';
        ctx.lineWidth = 2.0*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*2.45, 0, Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
    }
    return lock;
  }

  function drawBullets(now){
    for(const b of bullets){
      if(!b.alive) continue;
      const age = (now - b.t0)/1000;
      const t = clamp(age / b.tof, 0, 1);
      const x = b.aimW.x + (b.impactW.x - b.aimW.x) * t;
      const y = b.aimW.y + (b.impactW.y - b.aimW.y) * t;

      const p = worldToScreen(x,y);
      const a = worldToScreen(b.aimW.x, b.aimW.y);

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha=0.48;
      ctx.strokeStyle='rgba(255,255,255,1)';
      ctx.lineWidth=2.0*DPR;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(p.x,p.y); ctx.stroke();
      ctx.globalAlpha=0.85;
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.beginPath(); ctx.arc(p.x,p.y,2.5*DPR,0,Math.PI*2); ctx.fill();
      ctx.restore();

      if(age >= b.tof){
        b.alive=false;
        resolveBullet(b);
      }
    }
    for(let i=bullets.length-1;i>=0;i--) if(!bullets[i].alive) bullets.splice(i,1);
  }

  function drawUAV(now){
    if(now > uavActiveUntil) return;

    if(now >= uavNextPingAt){
      uavPingFlashUntil = now + UAV_PING_FLASH_MS;
      uavNextPingAt = now + UAV_PING_EVERY_MS;
      beep(740, 0.03, "sine", 0.03);
    }

    const id = currentTargetId();
    const t = (id===null) ? null : chars.find(c=>c.id===id && c.alive);
    if(!t) return;

    const p = worldToScreen(t.x, t.y);
    const flash = now <= uavPingFlashUntil;

    // top-center UAV message briefly
    if(now <= uavAnnounceUntil){
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      const w = 170*DPR, h = 30*DPR;
      const x = W/2 - w/2, y = 16*DPR;
      roundRect(x, y, w, h, 14*DPR);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,210,90,0.95)';
      ctx.font = `${Math.max(12, 14*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText("UAV ONLINE", W/2, y + h/2);
      ctx.restore();
    }

    const onScreen = (p.x >= 0 && p.x <= W && p.y >= 0 && p.y <= H);

    ctx.save();
    ctx.globalCompositeOperation='lighter';

    if(onScreen){
      const r = UAV_PING_RADIUS_PX * DPR;
      ctx.globalAlpha = flash ? 0.90 : 0.35;
      ctx.strokeStyle = 'rgba(255,210,90,1)';
      ctx.lineWidth = 2.2*DPR;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.stroke();

      ctx.globalAlpha = flash ? 0.60 : 0.18;
      ctx.fillStyle = 'rgba(255,210,90,1)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3.0*DPR, 0, Math.PI*2);
      ctx.fill();
    } else {
      const cx = W/2, cy = H/2;
      const vx = p.x - cx, vy = p.y - cy;
      const ang = Math.atan2(vy, vx);

      const pad = UAV_OFFSCREEN_EDGE_PAD * DPR;
      const ex = clamp(cx + Math.cos(ang)*(Math.min(cx,cy)-pad), pad, W-pad);
      const ey = clamp(cy + Math.sin(ang)*(Math.min(cx,cy)-pad), pad, H-pad);

      ctx.translate(ex, ey);
      ctx.rotate(ang);
      ctx.globalAlpha = flash ? 0.92 : 0.40;
      ctx.fillStyle = 'rgba(255,210,90,1)';
      ctx.beginPath();
      ctx.moveTo(18*DPR, 0);
      ctx.lineTo(-10*DPR, -8*DPR);
      ctx.lineTo(-6*DPR, 0);
      ctx.lineTo(-10*DPR, 8*DPR);
      ctx.closePath();
      ctx.fill();
    }

    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Scope overlay (always on)
  function drawScopeOverlay(lock){
    const cx = cross.x + recoil.x * DPR;
    const cy = cross.y + recoil.y * DPR;

    const r = (210 / Math.sqrt(zoom)) * DPR;

    ctx.save();
    ctx.globalAlpha=0.76;
    ctx.fillStyle='rgba(0,0,0,1)';
    ctx.fillRect(0,0,W,H);

    ctx.globalCompositeOperation='destination-out';
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation='source-over';

    ctx.globalAlpha=1;
    ctx.lineWidth=3*DPR;
    ctx.strokeStyle='rgba(255,255,255,0.20)';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

    ctx.save();
    ctx.translate(cx,cy);
    ctx.strokeStyle = lock ? 'rgba(120,255,190,0.90)' : 'rgba(235,240,255,0.78)';
    ctx.lineWidth = 1.8*DPR;
    const L = r - 18*DPR;
    const G = 16*DPR;
    ctx.beginPath();
    ctx.moveTo(-L,0); ctx.lineTo(-G,0);
    ctx.moveTo(G,0);  ctx.lineTo(L,0);
    ctx.moveTo(0,-L); ctx.lineTo(0,-G);
    ctx.moveTo(0,G);  ctx.lineTo(0,L);
    ctx.stroke();

    ctx.fillStyle = lock ? 'rgba(120,255,190,0.98)' : 'rgba(235,240,255,0.88)';
    ctx.beginPath(); ctx.arc(0,0,2.2*DPR,0,Math.PI*2); ctx.fill();

    if(performance.now() <= hitMarkerUntil){
      ctx.strokeStyle='rgba(255,255,255,0.96)';
      ctx.lineWidth=2.3*DPR;
      const s=10*DPR;
      ctx.beginPath();
      ctx.moveTo(-s,-s); ctx.lineTo(s,s);
      ctx.moveTo(s,-s);  ctx.lineTo(-s,s);
      ctx.stroke();
    }

    ctx.restore();

    ctx.globalAlpha=0.10;
    ctx.fillStyle='rgba(255,255,255,1)';
    ctx.beginPath();
    ctx.arc(cx-r*0.22, cy-r*0.22, r*0.42, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // ===== Wind =====
  function updateWind(now){
    wind.dir += Math.sin(now*0.00012) * 0.0007;
    if(!gust.active && Math.random() < 0.0016){
      gust.active=true;
      gust.extra=rand(1.5,4.2);
      gust.until=now + rand(900,1800);
    }
    if(gust.active && now >= gust.until){
      gust.active=false; gust.extra=0;
    }
  }

  // ===== Round control =====
  function startNextRound(){
    round++;
    roundTxt.textContent = String(round);
    timeLeft = ROUND_TIME_S;

    reserve = Math.min(180, reserve + 30);
    mag = MAG_SIZE;
    reloading=false;

    if(chars.filter(c=>c.alive).length < 28) spawn();
    else for(const c of chars) if(Math.random() < 0.28) c.alive = true;

    buildRoundTargets();
    updateAmmoUI();
  }

  function resetAll(){
    round=1;
    timeLeft=ROUND_TIME_S;

    shots=0; kills=0; streak=0; points=0;
    mag=MAG_SIZE; reserve=RESERVE_START;
    reloading=false;

    wind.base = rand(7, 14);
    wind.dir = Math.random()*Math.PI*2;
    gust.active=false; gust.extra=0;

    zoom=ZOOM_START;
    zoomTarget=ZOOM_START;

    bullets.length=0;

    recoil.x=0; recoil.y=0; recoil.vx=0; recoil.vy=0;
    recoilStep=0;

    uavActiveUntil=0; uavNextPingAt=0; uavPingFlashUntil=0; uavAnnounceUntil=0;
    uavArmed=true;

    spawn();
    buildRoundTargets();
    updateAmmoUI();

    roundTxt.textContent="1";
  }

  // ===== Touch: pinch zoom + two-finger reload =====
  function touchDist(t1, t2){
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.hypot(dx,dy);
  }

  canvas.addEventListener('touchstart', (e)=>{
    ensureAudio(); // allow sound unlock
    if(e.touches.length === 2){
      // two-finger tap -> reload (quick)
      // but if it becomes a pinch, we treat as pinch. We'll still allow reload if short.
      pinching = true;
      pinchStartDist = touchDist(e.touches[0], e.touches[1]);
      pinchStartZoom = zoomTarget;
      // small tick to confirm pinch mode
      clickTick(420, 0.03, 0.04);
    }
  }, { passive:false });

  canvas.addEventListener('touchmove', (e)=>{
    if(!pinching) return;
    if(e.touches.length !== 2) return;

    const d = touchDist(e.touches[0], e.touches[1]);
    const ratio = d / Math.max(10, pinchStartDist);

    // Smooth zoom mapping
    let z = pinchStartZoom * ratio;
    z = clamp(z, ZOOM_MIN, ZOOM_MAX);

    // zoom tick sound when passing thresholds
    const now = performance.now();
    const step = 0.12; // tick frequency
    const prevQ = Math.round(zoomTarget/step);
    const nextQ = Math.round(z/step);
    if(prevQ !== nextQ && now - lastZoomTickAt > 35){
      // higher pitch when zooming in, lower when zooming out
      const pitch = (z > zoomTarget) ? 720 : 440;
      clickTick(pitch, 0.02, 0.04);
      lastZoomTickAt = now;
    }

    zoomTarget = z;
    e.preventDefault();
  }, { passive:false });

  canvas.addEventListener('touchend', (e)=>{
    // if pinch ended quickly and minimal change, treat as reload shortcut
    if(pinching){
      const zDelta = Math.abs(zoomTarget - pinchStartZoom);
      if(zDelta < 0.10){
        reload();
      }
    }
    if(e.touches.length < 2){
      pinching=false;
    }
  }, { passive:false });

  // ===== Shoot button =====
  shootBtn.addEventListener('pointerdown', (e)=>{
    ensureAudio();
    shoot();
    e.preventDefault();
  }, { passive:false });

  // ===== Tilt permissions + listeners =====
  function isIOS(){
    return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  }

  async function requestTiltPermissionIfNeeded(){
    // On iOS 13+, need DeviceOrientationEvent.requestPermission()
    if(typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function"){
      permWrap.style.display = "flex";
    } else {
      // Android / others typically just work
      enableTilt();
    }
  }

  async function enableTilt(){
    try{
      if(typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function"){
        const res = await DeviceOrientationEvent.requestPermission();
        if(res !== "granted"){
          permWrap.style.display = "none";
          tilt.enabled=false;
          modeTxt.textContent = "MODE: MOBILE (NO TILT)";
          return;
        }
      }
      tilt.enabled=true;
      permWrap.style.display = "none";
      modeTxt.textContent = "MODE: MOBILE (TILT)";
      addEventListener('deviceorientation', onOri, true);
      beep(520, 0.06, "sine", 0.05);
    }catch{
      permWrap.style.display = "none";
      tilt.enabled=false;
      modeTxt.textContent = "MODE: MOBILE (NO TILT)";
    }
  }

  function onOri(ev){
    // beta: front/back tilt (-180..180), gamma: left/right (-90..90)
    const b = (typeof ev.beta === "number") ? ev.beta : 0;
    const g = (typeof ev.gamma === "number") ? ev.gamma : 0;

    // smooth
    tilt.sb = lerp(tilt.sb, b, TILT_SMOOTH);
    tilt.sg = lerp(tilt.sg, g, TILT_SMOOTH);
    tilt.beta = tilt.sb;
    tilt.gamma = tilt.sg;
  }

  enableTiltBtn.addEventListener('click', ()=>enableTilt());
  noTiltBtn.addEventListener('click', ()=>{
    permWrap.style.display="none";
    tilt.enabled=false;
    modeTxt.textContent="MODE: MOBILE (NO TILT)";
  });

  // ===== Main Loop =====
  function roundRectPath(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  let last = performance.now();
  function tick(now){
    const dt = Math.min(40, now-last);
    last = now;

    updateCrossCenter();

    // reload finish
    if(reloading && now >= reloadUntil){
      const need = MAG_SIZE - mag;
      const take = Math.min(need, reserve);
      mag += take;
      reserve -= take;
      reloading=false;
      updateAmmoUI();
      beep(520, 0.05, "sine", 0.04);
    }

    // timer
    timeLeft -= dt/1000;
    if(timeLeft <= 0){
      streak=0; uavArmed=true;
      startNextRound();
    }
    timerTxt.textContent = `${Math.max(0,timeLeft).toFixed(1)}s`;

    // wind
    updateWind(now);
    windTxt.textContent = `${effectiveWind().toFixed(1)} kt`;

    // smooth zoom
    zoom += (zoomTarget - zoom) * ZOOM_SPEED;
    zoomTxt.textContent = `${zoom.toFixed(1)}x`;

    // recoil recovery
    recoil.vx += (-recoil.x) * RECOIL_RETURN;
    recoil.vy += (-recoil.y) * RECOIL_RETURN;
    recoil.vx *= RECOIL_DAMP;
    recoil.vy *= RECOIL_DAMP;
    recoil.x += recoil.vx * (dt/16.67);
    recoil.y += recoil.vy * (dt/16.67);
    recoil.x = clamp(recoil.x, -40, 40);
    recoil.y = clamp(recoil.y, -90, 40);

    // tilt -> camera aim drift
    // We move camera by world units proportional to tilt * (1/zoom) so it feels consistent.
    if(tilt.enabled){
      const gx = deadzone(tilt.gamma);
      const by = deadzone(tilt.beta);

      // Convert degrees to world drift (scale with zoom so it doesn’t feel too fast when zoomed in)
      const scale = (1.0 / zoom) * 9.0; // world-units per degree
      cam.x += gx * TILT_SENS_X * scale;
      cam.y += by * TILT_SENS_Y * scale;
    }

    // clamp camera
    cam.x = clamp(cam.x, 200, WORLD_W-200);
    cam.y = clamp(cam.y, 200, WORLD_H-200);

    // apply camera shake decay
    cam.shakeX *= SHAKE_DECAY;
    cam.shakeY *= SHAKE_DECAY;

    // compute aim for dance/lock feedback
    const aimW = getAimWorld();

    // draw
    drawBackground();
    const lock = updateAndDrawChars(now, aimW);
    drawBullets(now);
    drawUAV(now);
    drawScopeOverlay(lock);

    // UI
    pointsTxt.textContent = String(points);
    killsTxt.textContent = String(kills);
    shotsTxt.textContent = String(shots);
    streakTxt.textContent = String(streak);
    leftTxt.textContent = String(Math.max(0, roundTargets.length - currentTargetIndex));
    updateObjectiveUI();

    requestAnimationFrame(tick);
  }

  // ===== Init =====
  function init(){
    resetAll();
    // show permission prompt on iOS, else enable tilt directly
    requestTiltPermissionIfNeeded();
    requestAnimationFrame(tick);
  }

  // Desktop fallback: allow mouse wheel zoom + click shoot (if opened on laptop)
  let isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
  if(!isTouch){
    modeTxt.textContent = "MODE: DESKTOP (MOUSE)";
    shootBtn.style.display = "none";
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX-rect.left)*DPR;
      const y = (e.clientY-rect.top)*DPR;
      // move camera toward mouse aim
      const w = screenToWorld(x,y);
      cam.x += (w.x - cam.x) * CAM_FOLLOW;
      cam.y += (w.y - cam.y) * CAM_FOLLOW;
    }, { passive:true });

    canvas.addEventListener('mousedown', ()=>{ ensureAudio(); shoot(); }, { passive:true });

    canvas.addEventListener('wheel', (e)=>{
      ensureAudio();
      const z = clamp(zoomTarget + (e.deltaY>0 ? -0.18 : 0.18), ZOOM_MIN, ZOOM_MAX);
      if(Math.abs(z-zoomTarget) > 0.01) clickTick(z>zoomTarget ? 720 : 440, 0.02, 0.04);
      zoomTarget = z;
      e.preventDefault();
    }, { passive:false });
  } else {
    // mobile: two-finger short tap already reloads, but add hardware key support if present
    addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='r') reload(); });
  }

  init();
})();
</script>
</body>
</html>
