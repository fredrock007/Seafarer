<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Sea Farer — COD Style Scope Hunt</title>
  <style>
    :root{
      --hud:#e9eefc;
      --hud2:#aab7ff;
      --ok:#75ffba;
      --bad:#ff6a6a;
      --warn:#ffcf5a;
      --glass: rgba(255,255,255,0.08);
      --line: rgba(255,255,255,0.16);
    }
    html,body{ height:100%; margin:0; overflow:hidden; background:#05060b; color:var(--hud);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      user-select:none; -webkit-user-select:none; touch-action:none;
    }
    #wrap{ position:relative; width:100vw; height:100vh; }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    .hud{
      position:absolute; left:14px; top:14px; pointer-events:none;
      display:flex; flex-direction:column; gap:10px; max-width:420px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.14);
      border-radius:14px;
      padding:10px 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }
    .title{ font-weight:800; letter-spacing:0.6px; font-size:12px; color:var(--hud2); text-transform:uppercase; margin-bottom:6px; }
    .row{ display:flex; justify-content:space-between; gap:12px; font-size:12px; line-height:1.35; }
    .row b{ color:var(--hud); }
    .hint{ font-size:12px; color: rgba(233,238,252,0.78); margin-top:8px; }

    .toast{
      position:absolute; right:14px; top:14px; width:min(520px, calc(100vw - 28px));
      display:flex; flex-direction:column; gap:10px; align-items:flex-end; pointer-events:none;
    }
    .msg{
      background: rgba(0,0,0,0.44);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      font-size:12px;
      color: rgba(233,238,252,0.90);
      max-width: 520px;
    }
    .msg b{ color: var(--warn); }

    .controls{
      position:absolute; right:14px; bottom:14px; width:min(520px, calc(100vw - 28px));
      pointer-events:auto;
    }
    button{
      appearance:none; border:none; cursor:pointer;
      border-radius:12px; padding:10px 12px;
      background: rgba(255,255,255,0.10);
      color: var(--hud);
      border: 1px solid rgba(255,255,255,0.14);
      font-weight:750; letter-spacing:0.2px;
    }
    button:hover{ background: rgba(255,255,255,0.14); }
    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .mini{ font-size:12px; opacity:0.92; color: rgba(233,238,252,0.80); }
    .kbd{
      font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.10);
      padding:2px 6px; border-radius:8px; color: rgba(233,238,252,0.92);
      white-space:nowrap;
    }

    .centerHUD{
      position:absolute; left:50%; transform:translateX(-50%);
      bottom:14px; pointer-events:none;
      width:min(640px, calc(100vw - 28px));
      display:flex; gap:10px; justify-content:center; align-items:center;
    }
    .pill{
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 999px;
      padding:8px 12px;
      backdrop-filter: blur(10px);
      font-size:12px;
      color: rgba(233,238,252,0.90);
      display:flex; gap:10px; align-items:center;
    }
    .pill b{ color: var(--hud); }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="panel">
      <div class="title">Sea Farer — COD Style Hunt</div>
      <div class="row"><span>Round</span><b id="roundTxt">1</b></div>
      <div class="row"><span>Timer</span><b id="timerTxt">60.0s</b></div>

      <div class="row"><span>Objective</span><b id="obj">—</b></div>
      <div class="row"><span>Hint (approx coords)</span><b id="hint">—</b></div>

      <div class="row"><span>ADS / Scope</span><b id="scopeTxt">OFF</b></div>
      <div class="row"><span>Ammo</span><b id="ammoTxt">30 / 90</b></div>
      <div class="row"><span>Reload</span><b id="reloadTxt">READY</b></div>

      <div class="row"><span>Wind</span><b id="wind">0.0 kt</b></div>
      <div class="row"><span>Range</span><b id="range">0 m</b></div>

      <div class="row"><span>Kills / Shots</span><b id="score">0 / 0</b></div>
      <div class="row"><span>Streak</span><b id="streak">0</b></div>

      <div class="hint">
        <b>COD controls:</b><br/>
        Aim with mouse/trackpad • <b>Right-click</b> ADS • <b>Left-click</b> shoot • <b>R</b> reload<br/>
        <span class="kbd">N</span> vision (optional) • <span class="kbd">Shift</span> steady (small) • <span class="kbd">Esc</span> reset round
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="centerHUD">
    <div class="pill">Aim Assist: <b>ON (ADS)</b></div>
    <div class="pill">Targets this round: <b id="targetsLeft">3</b></div>
    <div class="pill">Points: <b id="pointsTxt">0</b></div>
  </div>

  <div class="controls">
    <div class="panel">
      <div class="title">Quick Buttons</div>
      <div class="mini">
        Mobile: <b>Long-press</b> ADS • Tap shoot • Two-finger tap reload
      </div>
      <div class="btnRow" style="margin-top:10px;">
        <button id="resetBtn">Reset Round</button>
        <button id="shuffleBtn">Shuffle Crowd</button>
        <button id="visionBtn">Vision: Normal</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  const uiRound = document.getElementById('roundTxt');
  const uiTimer = document.getElementById('timerTxt');
  const uiObj   = document.getElementById('obj');
  const uiHint  = document.getElementById('hint');
  const uiScope = document.getElementById('scopeTxt');
  const uiAmmo  = document.getElementById('ammoTxt');
  const uiReload= document.getElementById('reloadTxt');
  const uiWind  = document.getElementById('wind');
  const uiRange = document.getElementById('range');
  const uiScore = document.getElementById('score');
  const uiStreak= document.getElementById('streak');
  const uiTargetsLeft = document.getElementById('targetsLeft');
  const uiPoints = document.getElementById('pointsTxt');

  const toastEl = document.getElementById('toast');
  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const visionBtn = document.getElementById('visionBtn');

  // ===== COD-FEEL CONFIG =====
  const WORLD_W = 2600;
  const WORLD_H = 1800;
  const NUM_CHAR = 95;

  const CHAR_SIZE = 15;
  const HIT_RADIUS = 26;          // forgiving
  const DANCE_RADIUS = 90;        // clear “you’re on target”
  const AIM_ASSIST_RADIUS = 120;  // magnet zone (ADS)

  const MUZZLE_V = 900;
  const MAX_TOF  = 0.9;

  const WIND_KT_TO_DRIFT = 0.28;  // mild (COD-ish)
  const WIND_BASE_MIN = 6, WIND_BASE_MAX = 14;

  // camera follow: COD = tight
  const CAM_FOLLOW = 0.18;

  // ADS smooth zoom
  const ZOOM_OFF = 1.0;
  const ZOOM_ON  = 3.2;
  const ZOOM_SPEED = 0.16;        // fast snap

  // reticle/scope
  const SCOPE_R_BASE = 200;

  // recoil + shake
  const SHAKE_ON_SHOT = 6;
  const SHAKE_DECAY = 0.86;

  // ammo / reload
  const MAG_SIZE = 30;
  const RESERVE_START = 90;
  const RELOAD_MS = 900;

  // round
  const TARGETS_PER_ROUND = 3;
  const ROUND_TIME_S = 60;

  // Vision (optional)
  const visionModes = ["Normal","Night Vision","Thermal"];
  let visionIndex = 0;

  // DPR
  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener('resize', resize);
  resize();

  // Helpers
  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const lerp=(a,b,t)=>a+(b-a)*t;

  // Simple sound via WebAudio (tiny, COD-ish feedback)
  let audioCtx = null;
  function beep(freq=880, dur=0.05, type="square", gain=0.05){
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    }catch{}
  }

  function toast(html, ms=1500){
    const div=document.createElement('div');
    div.className='msg';
    div.innerHTML=html;
    toastEl.appendChild(div);
    setTimeout(()=>{
      div.style.transition='opacity 260ms ease, transform 260ms ease';
      div.style.opacity='0';
      div.style.transform='translateY(-6px)';
      setTimeout(()=>div.remove(),320);
    }, ms);
  }

  // Cursor
  const cursor = { x: W/2, y: H/2 };
  const cursorWorld = { x: WORLD_W/2, y: WORLD_H/2 };

  // Camera
  const cam = { x: WORLD_W/2, y: WORLD_H/2, shakeX:0, shakeY:0 };

  // ADS/Zoom
  let scoped = false;
  let zoom = ZOOM_OFF;
  let zoomTarget = ZOOM_OFF;

  // Breath/steady (small effect, COD-ish)
  let steady = false;

  // Wind
  const wind = { base: rand(WIND_BASE_MIN, WIND_BASE_MAX), dir: Math.random()*Math.PI*2 };
  let gust = { extra:0, until:0, active:false };

  function effectiveWind(){ return wind.base + (gust.active ? gust.extra : 0); }

  // Stats
  let shots=0, kills=0, streak=0, points=0;

  // Ammo
  let mag = MAG_SIZE;
  let reserve = RESERVE_START;
  let reloading = false;
  let reloadUntil = 0;

  // Rounds + targets
  let round = 1;
  let timeLeft = ROUND_TIME_S;
  let roundTargets = []; // array of targetIds
  let currentTargetIndex = 0;

  // World
  const ICONS = [
    { name:"Pika-ish", glyph:"⚡", hue: 52 },
    { name:"DBZ-ish",  glyph:"✦", hue: 40 },
    { name:"Fighter",  glyph:"✊", hue: 10 },
    { name:"Sponge-ish", glyph:"▦", hue: 58 },
    { name:"Alien", glyph:"⬡", hue: 190 },
    { name:"Bot", glyph:"⬢", hue: 210 },
    { name:"Star", glyph:"✶", hue: 300 },
    { name:"Skull", glyph:"☠", hue: 350 }
  ];

  let chars = [];
  function spawn(){
    chars = [];
    for(let i=0;i<NUM_CHAR;i++){
      const icon = ICONS[(Math.random()*ICONS.length)|0];
      chars.push({
        id:i,
        x: rand(80, WORLD_W-80),
        y: rand(80, WORLD_H-80),
        alive:true,
        icon,
        seed: Math.random()*9999,
        scale: rand(0.90, 1.25),
        vx: rand(-24, 24),
        vy: rand(-18, 18),
        dance: 0
      });
    }
  }

  const stars = new Array(950).fill(0).map(()=>({
    x: Math.random()*WORLD_W,
    y: Math.random()*WORLD_H,
    r: Math.random()*1.6 + 0.25,
    a: Math.random()*0.8 + 0.15
  }));

  // Transform
  function worldToScreen(wx, wy){
    const sx = (wx - cam.x) * zoom + (W/(2*DPR));
    const sy = (wy - cam.y) * zoom + (H/(2*DPR));
    return { x: sx*DPR + cam.shakeX, y: sy*DPR + cam.shakeY };
  }
  function screenToWorld(sx, sy){
    const wx = ((sx - cam.shakeX)/DPR - (W/(2*DPR))) / zoom + cam.x;
    const wy = ((sy - cam.shakeY)/DPR - (H/(2*DPR))) / zoom + cam.y;
    return { x: wx, y: wy };
  }

  // Input
  function setCursorFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (('clientX' in e) ? e.clientX : e.touches[0].clientX) - rect.left;
    const y = (('clientY' in e) ? e.clientY : e.touches[0].clientY) - rect.top;
    cursor.x = x * DPR;
    cursor.y = y * DPR;
  }
  canvas.addEventListener('contextmenu', (e)=>e.preventDefault());

  canvas.addEventListener('mousemove', (e)=>setCursorFromEvent(e), { passive:true });
  canvas.addEventListener('mousedown', (e)=>{
    setCursorFromEvent(e);
    if(e.button === 2){ toggleScope(); return; }
    if(e.button === 0){ shoot(); return; }
  }, { passive:true });

  // Mobile: long press ADS, tap shoot, two-finger tap reload
  let pressTimer = null;
  canvas.addEventListener('touchstart', (e)=>{
    setCursorFromEvent(e);
    if(e.touches && e.touches.length >= 2){
      reload();
      return;
    }
    pressTimer = setTimeout(()=>{ toggleScope(); pressTimer=null; }, 330);
  }, { passive:false });
  canvas.addEventListener('touchmove', (e)=>{ setCursorFromEvent(e); }, { passive:false });
  canvas.addEventListener('touchend', ()=>{
    if(pressTimer){
      clearTimeout(pressTimer);
      pressTimer=null;
      shoot();
    }
  }, { passive:false });

  addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='r') reload();
    if(k==='n') cycleVision();
    if(k==='escape') resetRound();
    if(e.key === 'Shift') steady = true;
  });
  addEventListener('keyup', (e)=>{
    if(e.key === 'Shift') steady = false;
  });

  resetBtn.addEventListener('click', resetRound);
  shuffleBtn.addEventListener('click', ()=>{
    spawn(); buildRoundTargets();
    toast("Crowd shuffled. Targets re-picked.");
  });
  visionBtn.addEventListener('click', cycleVision);

  function toggleScope(){
    scoped = !scoped;
    zoomTarget = scoped ? ZOOM_ON : ZOOM_OFF;
    uiScope.textContent = scoped ? "ON" : "OFF";
    beep(scoped ? 520 : 420, 0.05, "sine", 0.05);
  }
  function cycleVision(){
    visionIndex = (visionIndex+1) % visionModes.length;
    visionBtn.textContent = `Vision: ${visionModes[visionIndex]}`;
    toast(`Vision: <b>${visionModes[visionIndex]}</b>`, 900);
  }

  // Round targets
  function quant(v, step){ return Math.round(v/step)*step; }
  function buildRoundTargets(){
    const alive = chars.filter(c=>c.alive);
    roundTargets = [];
    currentTargetIndex = 0;
    // pick 3 unique alive targets
    const pool = alive.slice();
    for(let i=0;i<TARGETS_PER_ROUND && pool.length;i++){
      const idx = (Math.random()*pool.length)|0;
      roundTargets.push(pool[idx].id);
      pool.splice(idx,1);
    }
    updateObjectiveUI();
  }

  function currentTargetId(){
    return roundTargets[currentTargetIndex] ?? null;
  }

  function updateObjectiveUI(){
    const id = currentTargetId();
    const t = (id===null) ? null : chars.find(c=>c.id===id && c.alive);
    if(!t){
      uiObj.textContent = "—";
      uiHint.textContent = "—";
      return;
    }
    uiObj.textContent = `Eliminate: ${t.icon.name}`;
    uiHint.textContent = `Near X:${quant(t.x, 90)}  Y:${quant(t.y, 90)}`;
    uiTargetsLeft.textContent = String(roundTargets.length - currentTargetIndex);
  }

  // Ammo UI
  function updateAmmoUI(){
    uiAmmo.textContent = `${mag} / ${reserve}`;
    uiReload.textContent = reloading ? "RELOADING" : "READY";
  }

  function reload(){
    if(reloading) return;
    if(mag >= MAG_SIZE) { beep(220, 0.06, "square", 0.04); return; }
    if(reserve <= 0) { toast("No reserve ammo.", 900); beep(160, 0.08, "square", 0.05); return; }

    reloading = true;
    reloadUntil = performance.now() + RELOAD_MS;
    updateAmmoUI();
    toast("Reloading...", 800);
    beep(300, 0.06, "sine", 0.05);
  }

  // Ballistics
  function calcTof(range){
    const t = range / MUZZLE_V;
    return clamp(t, 0.04, MAX_TOF);
  }
  function leadDotWorld(aimW, tof){
    const ws = effectiveWind();
    const drift = ws * tof * WIND_KT_TO_DRIFT;
    return {
      x: aimW.x + Math.cos(wind.dir)*drift,
      y: aimW.y + Math.sin(wind.dir)*drift
    };
  }

  const bullets = [];
  function shoot(){
    if(reloading) return;

    if(mag <= 0){
      // empty click
      beep(120, 0.05, "square", 0.06);
      toast("Out of ammo. Reload (R).", 900);
      return;
    }

    mag--;
    shots++;
    updateAmmoUI();

    cam.shakeX += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;
    cam.shakeY += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;

    const now = performance.now();
    // aim world with aim assist if ADS
    const aimW = getAimedWorldWithAssist(now);
    const range = dist(aimW.x, aimW.y, cam.x, cam.y);
    const tof = calcTof(range);
    const impactW = leadDotWorld(aimW, tof);

    bullets.push({ t0: now, tof, aimW:{...aimW}, impactW, alive:true });

    // shot sound
    beep(880, 0.03, "square", 0.06);
    beep(220, 0.04, "sine", 0.03);

    uiScore.textContent = `${kills} / ${shots}`;
  }

  // Hitmarker + killfeed
  let hitMarkerUntil = 0;
  let killFeedUntil = 0;
  let killFeedText = "";

  function setHitMarker(){
    hitMarkerUntil = performance.now() + 140;
  }

  function setKillFeed(msg){
    killFeedText = msg;
    killFeedUntil = performance.now() + 1100;
  }

  function resolveBullet(b){
    let best=null, bestD=Infinity;
    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(b.impactW.x, b.impactW.y, c.x, c.y);
      if(d < HIT_RADIUS && d < bestD){
        best=c; bestD=d;
      }
    }

    if(best){
      best.alive=false;

      kills++;
      streak++;
      points += 100 + Math.min(150, streak*10);

      const range = Math.round(dist(best.x, best.y, cam.x, cam.y));
      setHitMarker();
      setKillFeed(`Target down, ${range}m`);

      // confirm sound
      beep(1100, 0.05, "sine", 0.06);

      // objective check
      const tgtId = currentTargetId();
      if(tgtId !== null && best.id === tgtId){
        points += 150;
        toast(`Objective eliminated: <b>${best.icon.name}</b> (+150)`, 1400);
        currentTargetIndex++;
        if(currentTargetIndex >= roundTargets.length){
          toast(`<b>Round clear.</b> Reload and get ready.`, 1700);
          startNextRound();
        } else {
          updateObjectiveUI();
        }
      } else {
        toast(`Eliminated <b>${best.icon.name}</b>.`, 1100);
      }

      // streak callouts
      if(streak === 3) toast(`<b>3 Streak!</b> Keep it going.`, 1200);
      if(streak === 5) toast(`<b>5 Streak!</b> You’re cooking.`, 1200);
      if(streak === 7) toast(`<b>7 Streak!</b> Absolute menace.`, 1200);

    } else {
      // miss resets streak (COD-ish)
      if(streak > 0) toast(`Miss. Streak reset.`, 900);
      streak = 0;
      beep(180, 0.06, "square", 0.04);
    }

    uiScore.textContent = `${kills} / ${shots}`;
    uiStreak.textContent = String(streak);
    uiPoints.textContent = String(points);
  }

  // Aim assist (magnet) when ADS:
  // pulls aim world toward closest target within radius
  function getAimedWorldWithAssist(now){
    const aimWraw = screenToWorld(cursor.x, cursor.y);

    if(!scoped) return aimWraw;

    // find nearest alive target within assist radius (in world space)
    let best=null, bestD=Infinity;
    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(aimWraw.x, aimWraw.y, c.x, c.y);
      if(d < AIM_ASSIST_RADIUS && d < bestD){
        best=c; bestD=d;
      }
    }
    if(!best) return aimWraw;

    // stronger assist when steady (Shift)
    const strength = steady ? 0.35 : 0.22;
    return {
      x: lerp(aimWraw.x, best.x, strength),
      y: lerp(aimWraw.y, best.y, strength),
    };
  }

  // Wind/gust mild
  function updateWind(now){
    wind.dir += Math.sin(now*0.00012) * 0.0007;
    if(!gust.active && Math.random() < 0.0018){
      gust.active = true;
      gust.extra = rand(1.5, 4.5);
      gust.until = now + rand(900, 1900);
    }
    if(gust.active && now >= gust.until){
      gust.active=false; gust.extra=0;
    }
    uiWind.textContent = `${effectiveWind().toFixed(1)} kt`;
  }

  // Background
  function drawBackground(){
    ctx.clearRect(0,0,W,H);
    const g = ctx.createRadialGradient(W*0.35,H*0.30, 10, W*0.35,H*0.30, Math.max(W,H)*0.9);
    g.addColorStop(0, 'rgba(16,26,85,1)');
    g.addColorStop(0.45,'rgba(7,10,20,1)');
    g.addColorStop(1,'rgba(5,6,11,1)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(const s of stars){
      const p = worldToScreen(s.x, s.y);
      if(p.x<-40||p.y<-40||p.x>W+40||p.y>H+40) continue;
      ctx.globalAlpha = s.a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s.r*DPR, 0, Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.fill();
    }
    ctx.restore();

    // grid subtle
    ctx.save();
    ctx.globalAlpha=0.06;
    ctx.strokeStyle='rgba(255,255,255,1)';
    ctx.lineWidth=1*DPR;
    const grid=150;
    const tl = screenToWorld(0,0);
    const br = screenToWorld(W,H);
    const startX = Math.floor(tl.x/grid)*grid;
    const endX = Math.ceil(br.x/grid)*grid;
    const startY = Math.floor(tl.y/grid)*grid;
    const endY = Math.ceil(br.y/grid)*grid;
    for(let x=startX;x<=endX;x+=grid){
      const a=worldToScreen(x,startY), b=worldToScreen(x,endY);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    for(let y=startY;y<=endY;y+=grid){
      const a=worldToScreen(startX,y), b=worldToScreen(endX,y);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();
  }

  // Draw characters (COD readability + reactions)
  function updateAndDrawChars(now){
    const aimW = getAimedWorldWithAssist(now);
    uiRange.textContent = `${Math.round(dist(aimW.x, aimW.y, cam.x, cam.y))} m`;

    let lock=null, lockD=1e9;
    const tgtId = currentTargetId();

    for(const c of chars){
      if(!c.alive) continue;

      // movement
      c.x += c.vx * 0.016;
      c.y += c.vy * 0.016;

      if(c.x<80||c.x>WORLD_W-80) c.vx*=-1;
      if(c.y<80||c.y>WORLD_H-80) c.vy*=-1;
      c.x=clamp(c.x,80,WORLD_W-80);
      c.y=clamp(c.y,80,WORLD_H-80);

      // dance cue when ADS and near crosshair
      const d = dist(aimW.x, aimW.y, c.x, c.y);
      const wantDance = (scoped && d < DANCE_RADIUS) ? 1 : 0;
      c.dance += (wantDance - c.dance) * 0.22;

      // wiggle
      const phase = (now*0.007 + c.seed) % (Math.PI*2);
      const wig = c.dance * 8;
      const dx = Math.sin(phase*3.2) * wig;
      const dy = Math.cos(phase*2.5) * wig;

      const px = c.x + dx;
      const py = c.y + dy;

      if(scoped && d < DANCE_RADIUS && d < lockD){
        lock=c; lockD=d;
      }

      const p = worldToScreen(px, py);
      const size = CHAR_SIZE * c.scale * DPR * (0.88 + 0.12*zoom);

      ctx.save();
      ctx.translate(p.x, p.y);

      // base color
      const hue = c.icon.hue;
      ctx.shadowColor = `hsla(${hue}, 90%, 65%, 0.55)`;
      ctx.shadowBlur = 12 * DPR;

      // body diamond
      ctx.beginPath();
      ctx.moveTo(0, -size*1.35);
      ctx.lineTo(size*1.25, 0);
      ctx.lineTo(0, size*1.35);
      ctx.lineTo(-size*1.25, 0);
      ctx.closePath();
      ctx.fillStyle = `hsla(${hue}, 85%, 55%, 0.95)`;
      ctx.fill();

      // outline
      ctx.shadowBlur=0;
      ctx.lineWidth=1.2*DPR;
      ctx.strokeStyle='rgba(0,0,0,0.55)';
      ctx.stroke();

      // glyph
      ctx.fillStyle='rgba(255,255,255,0.90)';
      ctx.font = `${Math.max(12, 14*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(c.icon.glyph, 0, 0);

      // dance ring when locked-ish
      if(c.dance > 0.2){
        ctx.globalAlpha = 0.85;
        ctx.strokeStyle = 'rgba(117,255,186,0.70)';
        ctx.lineWidth = 1.5*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*1.9, -0.6, 0.6);
        ctx.stroke();
      }

      // objective ping (COD: helpful but not too easy when ADS)
      if(tgtId !== null && c.id === tgtId){
        ctx.globalAlpha = scoped ? 0.0 : 0.22;
        ctx.strokeStyle = 'rgba(255,207,90,0.95)';
        ctx.lineWidth = 2.1*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*2.4, 0, Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
    }

    return lock;
  }

  // Tracers
  function drawBullets(now){
    for(const b of bullets){
      if(!b.alive) continue;
      const age = (now - b.t0)/1000;
      const t = clamp(age / b.tof, 0, 1);
      const x = b.aimW.x + (b.impactW.x - b.aimW.x) * t;
      const y = b.aimW.y + (b.impactW.y - b.aimW.y) * t;

      const p = worldToScreen(x,y);
      const a = worldToScreen(b.aimW.x, b.aimW.y);

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha=0.50;
      ctx.strokeStyle='rgba(255,255,255,1)';
      ctx.lineWidth=2.0*DPR;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(p.x,p.y); ctx.stroke();
      ctx.globalAlpha=0.85;
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.beginPath(); ctx.arc(p.x,p.y,2.6*DPR,0,Math.PI*2); ctx.fill();
      ctx.restore();

      if(age >= b.tof){
        b.alive=false;
        resolveBullet(b);
      }
    }
    for(let i=bullets.length-1;i>=0;i--) if(!bullets[i].alive) bullets.splice(i,1);
  }

  // Vision post (optional)
  function applyVisionPost(){
    const mode = visionModes[visionIndex];
    if(mode==="Normal") return;
    ctx.save();
    ctx.globalCompositeOperation='source-atop';
    if(mode==="Night Vision"){
      ctx.globalAlpha=0.22;
      ctx.fillStyle='rgb(40,255,120)';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=0.10;
      ctx.fillStyle='rgba(0,0,0,0.65)';
      for(let y=0;y<H;y+=6*DPR) ctx.fillRect(0,y,W,1*DPR);
    }
    if(mode==="Thermal"){
      ctx.globalAlpha=0.14;
      ctx.fillStyle='rgb(255,120,30)';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=0.18;
      const g=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.18,W/2,H/2,Math.min(W,H)*0.72);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,'rgba(0,0,0,0.65)');
      ctx.fillStyle=g;
      ctx.fillRect(0,0,W,H);
    }
    ctx.restore();
  }

  // COD reticle + hitmarker + killfeed
  function drawHUDOverlay(now, lock){
    // If not scoped, draw simple crosshair
    if(!scoped){
      const cx = cursor.x, cy = cursor.y;
      ctx.save();
      ctx.globalAlpha = 0.80;
      ctx.strokeStyle = 'rgba(233,238,252,0.72)';
      ctx.lineWidth = 2.0*DPR;
      const L = 14*DPR, G = 6*DPR;
      ctx.beginPath();
      ctx.moveTo(cx-L, cy); ctx.lineTo(cx-G, cy);
      ctx.moveTo(cx+G, cy); ctx.lineTo(cx+L, cy);
      ctx.moveTo(cx, cy-L); ctx.lineTo(cx, cy-G);
      ctx.moveTo(cx, cy+G); ctx.lineTo(cx, cy+L);
      ctx.stroke();
      ctx.restore();
    } else {
      // Scope overlay
      const cx = cursor.x, cy = cursor.y;
      const r = (SCOPE_R_BASE / Math.sqrt(zoom)) * DPR;

      ctx.save();
      ctx.globalAlpha=0.74;
      ctx.fillStyle='rgba(0,0,0,1)';
      ctx.fillRect(0,0,W,H);

      ctx.globalCompositeOperation='destination-out';
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
      ctx.globalCompositeOperation='source-over';

      // rim
      ctx.globalAlpha=1;
      ctx.lineWidth=3*DPR;
      ctx.strokeStyle='rgba(255,255,255,0.22)';
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

      // reticle
      ctx.save();
      ctx.translate(cx,cy);
      ctx.strokeStyle = lock ? 'rgba(117,255,186,0.90)' : 'rgba(233,238,252,0.78)';
      ctx.lineWidth = 1.8*DPR;
      const L = r - 18*DPR;
      const G = 16*DPR;
      ctx.beginPath();
      ctx.moveTo(-L,0); ctx.lineTo(-G,0);
      ctx.moveTo(G,0);  ctx.lineTo(L,0);
      ctx.moveTo(0,-L); ctx.lineTo(0,-G);
      ctx.moveTo(0,G);  ctx.lineTo(0,L);
      ctx.stroke();

      ctx.fillStyle = lock ? 'rgba(117,255,186,0.98)' : 'rgba(233,238,252,0.88)';
      ctx.beginPath(); ctx.arc(0,0,2.2*DPR,0,Math.PI*2); ctx.fill();

      // hitmarker
      if(performance.now() <= hitMarkerUntil){
        ctx.strokeStyle='rgba(255,255,255,0.96)';
        ctx.lineWidth=2.3*DPR;
        const s=10*DPR;
        ctx.beginPath();
        ctx.moveTo(-s,-s); ctx.lineTo(s,s);
        ctx.moveTo(s,-s);  ctx.lineTo(-s,s);
        ctx.stroke();
      }
      ctx.restore();

      // glare
      ctx.globalAlpha=0.10;
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.beginPath();
      ctx.arc(cx-r*0.22, cy-r*0.22, r*0.42, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // kill feed text
    if(performance.now() <= killFeedUntil){
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      const pad = 10*DPR;
      const text = killFeedText;
      ctx.font = `${Math.max(12, 14*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      const tw = ctx.measureText(text).width;
      const x = W - (tw + pad*2) - 18*DPR;
      const y = 110*DPR;
      const h = 28*DPR;
      roundRect(x, y, tw + pad*2, h, 12*DPR);
      ctx.fill();
      ctx.fillStyle = 'rgba(233,238,252,0.92)';
      ctx.textBaseline='middle';
      ctx.fillText(text, x+pad, y + h/2);
      ctx.restore();
    }
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Round/timer loop
  function startNextRound(){
    round++;
    uiRound.textContent = String(round);
    timeLeft = ROUND_TIME_S;

    // reward ammo a bit
    reserve = Math.min(180, reserve + 30);
    mag = MAG_SIZE;
    reloading = false;

    // respawn some crowd
    if(chars.filter(c=>c.alive).length < 25){
      spawn();
    } else {
      // revive a bunch if needed (keep variety)
      for(const c of chars){
        if(Math.random() < 0.35) c.alive = true;
      }
    }

    buildRoundTargets();
    updateAmmoUI();
    toast(`<b>Round ${round}</b> — new targets.`, 1400);
  }

  function resetRound(){
    round = 1;
    timeLeft = ROUND_TIME_S;

    shots=0; kills=0; streak=0; points=0;
    mag = MAG_SIZE; reserve = RESERVE_START;
    reloading = false;

    wind.base = rand(WIND_BASE_MIN, WIND_BASE_MAX);
    wind.dir = Math.random()*Math.PI*2;
    gust.active=false; gust.extra=0; gust.until=0;

    scoped = false;
    zoom = ZOOM_OFF; zoomTarget = ZOOM_OFF;

    bullets.length = 0;

    spawn();
    buildRoundTargets();
    updateAmmoUI();

    uiRound.textContent = "1";
    uiScope.textContent = "OFF";
    uiScore.textContent = "0 / 0";
    uiStreak.textContent = "0";
    uiPoints.textContent = "0";
    toast("Round reset.", 1100);
  }

  // Main loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min(40, now-last);
    last = now;

    // reload finish
    if(reloading && now >= reloadUntil){
      const need = MAG_SIZE - mag;
      const take = Math.min(need, reserve);
      mag += take;
      reserve -= take;
      reloading = false;
      updateAmmoUI();
      beep(520, 0.05, "sine", 0.05);
      toast("Reload complete.", 900);
    }

    // smooth ADS zoom
    zoom += (zoomTarget - zoom) * ZOOM_SPEED;

    // compute aim world (with assist if ADS)
    const aimW = getAimedWorldWithAssist(now);
    cursorWorld.x = aimW.x;
    cursorWorld.y = aimW.y;

    // camera follows aim (COD)
    cam.x += (aimW.x - cam.x) * CAM_FOLLOW;
    cam.y += (aimW.y - cam.y) * CAM_FOLLOW;

    // clamp camera
    cam.x = clamp(cam.x, 200, WORLD_W-200);
    cam.y = clamp(cam.y, 200, WORLD_H-200);

    // camera shake
    cam.shakeX *= SHAKE_DECAY;
    cam.shakeY *= SHAKE_DECAY;

    // timer
    timeLeft -= dt/1000;
    if(timeLeft <= 0){
      toast(`<b>Time!</b> New round.`, 1200);
      streak = 0;
      uiStreak.textContent = "0";
      startNextRound();
    }
    uiTimer.textContent = `${Math.max(0, timeLeft).toFixed(1)}s`;

    updateWind(now);

    drawBackground();

    // lock: closest target in dance radius
    let lock = updateAndDrawChars(now);

    drawBullets(now);
    applyVisionPost();
    drawHUDOverlay(now, lock);

    // UI refresh
    uiWind.textContent = `${effectiveWind().toFixed(1)} kt`;
    uiScore.textContent = `${kills} / ${shots}`;
    uiStreak.textContent = String(streak);
    uiPoints.textContent = String(points);
    updateObjectiveUI();

    requestAnimationFrame(tick);
  }

  // Init
  function init(){
    spawn();
    buildRoundTargets();
    updateAmmoUI();
    uiRound.textContent = "1";
    uiTimer.textContent = `${ROUND_TIME_S.toFixed(1)}s`;
    uiScope.textContent = "OFF";
    uiWind.textContent = `${effectiveWind().toFixed(1)} kt`;
    uiScore.textContent = "0 / 0";
    uiStreak.textContent = "0";
    uiPoints.textContent = "0";

    toast(`COD-style: <b>Right-click ADS</b>, targets dance when you’re on them.`, 2400);
    toast(`Reload with <b>R</b>. Rounds are <b>${ROUND_TIME_S}s</b> with ${TARGETS_PER_ROUND} objectives.`, 2400);
    requestAnimationFrame(tick);
  }
  init();

})();
</script>
</body>
</html>
