<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Sea Farer — Modern Warfare Scope Hunt</title>
  <style>
    :root{
      --hud: rgba(235,240,255,0.92);
      --hud2: rgba(235,240,255,0.72);
      --line: rgba(255,255,255,0.16);
      --glass: rgba(255,255,255,0.07);
      --ok: rgba(120,255,190,0.95);
      --warn: rgba(255,210,90,0.95);
      --bad: rgba(255,106,106,0.95);
    }

    html,body{height:100%; margin:0; overflow:hidden; background:#05060b; color:var(--hud);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      user-select:none; -webkit-user-select:none; touch-action:none;
    }
    #wrap{position:relative; width:100vw; height:100vh;}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}

    /* MW-like minimal HUD */
    .mw-top{
      position:absolute; left:14px; top:12px;
      pointer-events:none;
      display:flex; flex-direction:column; gap:8px;
      width:min(380px, calc(100vw - 28px));
    }
    .mw-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 46px rgba(0,0,0,0.38);
    }
    .mw-title{
      display:flex; align-items:center; justify-content:space-between;
      font-size:12px; letter-spacing:0.6px; text-transform:uppercase;
      color: var(--hud2); font-weight:800;
      margin-bottom:6px;
    }
    .mw-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      font-size:12px;
      color: var(--hud2);
      line-height:1.35;
    }
    .mw-grid b{ color: var(--hud); font-weight:800; }

    .mw-bottom{
      position:absolute; left:14px; bottom:14px;
      pointer-events:none;
      display:flex; gap:10px; flex-wrap:wrap;
      width:min(520px, calc(100vw - 28px));
    }
    .pill{
      background: rgba(0,0,0,0.38);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:999px;
      padding:8px 12px;
      backdrop-filter: blur(10px);
      color: var(--hud2);
      font-size:12px;
      display:flex; gap:10px; align-items:center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
    }
    .pill b{ color: var(--hud); }

    /* Kill banner (MW-ish) */
    .banner{
      position:absolute;
      left:50%; transform:translateX(-50%);
      bottom:84px;
      pointer-events:none;
      opacity:0;
      transition: opacity 160ms ease, transform 160ms ease;
      background: rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      padding:10px 14px;
      backdrop-filter: blur(12px);
      color: var(--hud);
      font-size:13px;
      letter-spacing:0.2px;
      box-shadow: 0 12px 46px rgba(0,0,0,0.45);
      white-space:nowrap;
    }
    .banner.show{
      opacity:1;
      transform:translateX(-50%) translateY(-4px);
    }
    .banner small{ color: var(--hud2); font-size:12px; margin-left:10px; }

    /* Right-side tiny tips */
    .tips{
      position:absolute; right:14px; top:12px; width:min(520px, calc(100vw - 28px));
      pointer-events:none;
      display:flex; flex-direction:column; gap:10px; align-items:flex-end;
    }
    .tip{
      background: rgba(0,0,0,0.44);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      font-size:12px;
      color: var(--hud2);
      max-width: 520px;
    }
    .tip b{ color: var(--warn); }

    /* Buttons (optional, keep clean) */
    .controls{
      position:absolute; right:14px; bottom:14px;
      pointer-events:auto;
    }
    .rowbtn{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      appearance:none; border:none; cursor:pointer;
      border-radius:12px; padding:10px 12px;
      background: rgba(255,255,255,0.10);
      color: var(--hud);
      border: 1px solid rgba(255,255,255,0.14);
      font-weight:800; letter-spacing:0.2px;
    }
    button:hover{ background: rgba(255,255,255,0.14); }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="mw-top">
    <div class="mw-card">
      <div class="mw-title">
        <span>Sea Farer — Modern Warfare</span>
        <span id="adsTxt">ADS: OFF</span>
      </div>
      <div class="mw-grid">
        <div>Round <b id="roundTxt">1</b></div>
        <div>Timer <b id="timerTxt">60.0s</b></div>
        <div>Objective <b id="objTxt">—</b></div>
        <div>Hint <b id="hintTxt">—</b></div>
        <div>Ammo <b id="ammoTxt">30 / 90</b></div>
        <div>Wind <b id="windTxt">0.0 kt</b></div>
        <div>Range <b id="rangeTxt">0 m</b></div>
        <div>Points <b id="pointsTxt">0</b></div>
      </div>
    </div>
  </div>

  <div class="mw-bottom">
    <div class="pill">Kills <b id="killsTxt">0</b> / Shots <b id="shotsTxt">0</b></div>
    <div class="pill">Streak <b id="streakTxt">0</b></div>
    <div class="pill">Targets left <b id="leftTxt">3</b></div>
  </div>

  <div class="banner" id="banner">Target Down <small id="bannerSub">+100</small></div>

  <div class="tips" id="tips"></div>

  <div class="controls">
    <div class="rowbtn">
      <button id="resetBtn">Reset</button>
      <button id="shuffleBtn">Shuffle</button>
      <button id="visionBtn">Vision: Normal</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  // UI
  const adsTxt = document.getElementById('adsTxt');
  const roundTxt = document.getElementById('roundTxt');
  const timerTxt = document.getElementById('timerTxt');
  const objTxt = document.getElementById('objTxt');
  const hintTxt = document.getElementById('hintTxt');
  const ammoTxt = document.getElementById('ammoTxt');
  const windTxt = document.getElementById('windTxt');
  const rangeTxt = document.getElementById('rangeTxt');
  const pointsTxt = document.getElementById('pointsTxt');

  const killsTxt = document.getElementById('killsTxt');
  const shotsTxt = document.getElementById('shotsTxt');
  const streakTxt = document.getElementById('streakTxt');
  const leftTxt = document.getElementById('leftTxt');

  const banner = document.getElementById('banner');
  const bannerSub = document.getElementById('bannerSub');
  const tipsEl = document.getElementById('tips');

  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const visionBtn = document.getElementById('visionBtn');

  // ===== MW FEEL CONFIG =====
  const WORLD_W = 2800;
  const WORLD_H = 1900;

  const NUM_CHAR = 95;
  const CHAR_SIZE = 15;

  // More MW-like: less arcade, still playable
  const HIT_RADIUS = 24;
  const AIM_ASSIST_RADIUS = 95;     // smaller than arcade
  const AIM_ASSIST_STRENGTH = 0.16; // subtle magnet
  const DANCE_RADIUS = 85;          // cue: on-target

  // Ballistics (mild)
  const MUZZLE_V = 980;
  const MAX_TOF  = 0.85;
  const WIND_KT_TO_DRIFT = 0.30; // drift matters slightly

  // Camera: tight, MW feel
  const CAM_FOLLOW = 0.16;

  // ADS: fast snap
  const ZOOM_OFF = 1.0;
  const ZOOM_ON  = 3.4;
  const ZOOM_SPEED = 0.18;

  // Sway: MW-ish (small), reduced when holding breath (Shift)
  const SWAY_MAG = 1.35;
  const SWAY_SPEED = 0.0016;

  // Recoil / shake (cleaner than arcade)
  const SHAKE_ON_SHOT = 5.5;
  const SHAKE_DECAY = 0.86;

  // Ammo
  const MAG_SIZE = 30;
  const RESERVE_START = 90;
  const RELOAD_MS = 900;

  // Round system
  const TARGETS_PER_ROUND = 3;
  const ROUND_TIME_S = 60;

  // Vision
  const visionModes = ["Normal","Night Vision","Thermal"];
  let visionIndex = 0;

  // DPR resize
  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener('resize', resize);
  resize();

  // Helpers
  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const lerp=(a,b,t)=>a+(b-a)*t;

  // Tiny audio (kept subtle)
  let audioCtx = null;
  function beep(freq=880, dur=0.05, type="square", gain=0.04){
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    }catch{}
  }

  function tip(html, ms=1800){
    const div = document.createElement('div');
    div.className='tip';
    div.innerHTML = html;
    tipsEl.appendChild(div);
    setTimeout(()=>{
      div.style.transition='opacity 260ms ease, transform 260ms ease';
      div.style.opacity='0';
      div.style.transform='translateY(-6px)';
      setTimeout(()=>div.remove(),320);
    }, ms);
  }

  function showBanner(text, sub="+100", ms=900){
    banner.textContent = text + " ";
    bannerSub.textContent = sub;
    banner.classList.add("show");
    setTimeout(()=>banner.classList.remove("show"), ms);
  }

  // Cursor
  const cursor = { x: W/2, y: H/2 };

  // Camera
  const cam = { x: WORLD_W/2, y: WORLD_H/2, shakeX:0, shakeY:0 };

  // ADS + zoom
  let scoped=false;
  let zoom=ZOOM_OFF;
  let zoomTarget=ZOOM_OFF;

  // Breath hold (Shift) reduces sway + slightly reduces aim assist “fight”
  let holdBreath=false;

  // Wind
  const wind = { base: rand(7, 14), dir: Math.random()*Math.PI*2 };
  let gust = { extra:0, until:0, active:false };
  function effectiveWind(){ return wind.base + (gust.active ? gust.extra : 0); }

  // Ammo/reload
  let mag = MAG_SIZE;
  let reserve = RESERVE_START;
  let reloading=false;
  let reloadUntil=0;

  // Score/stats
  let shots=0, kills=0, streak=0, points=0;

  // Round
  let round=1;
  let timeLeft=ROUND_TIME_S;
  let roundTargets=[];
  let currentTargetIndex=0;

  // World content
  const ICONS = [
    { name:"Pika-ish", glyph:"⚡", hue: 52 },
    { name:"DBZ-ish",  glyph:"✦", hue: 40 },
    { name:"Fighter",  glyph:"✊", hue: 10 },
    { name:"Sponge-ish", glyph:"▦", hue: 58 },
    { name:"Alien", glyph:"⬡", hue: 190 },
    { name:"Bot", glyph:"⬢", hue: 210 },
    { name:"Star", glyph:"✶", hue: 300 },
    { name:"Skull", glyph:"☠", hue: 350 }
  ];

  let chars=[];
  function spawn(){
    chars=[];
    for(let i=0;i<NUM_CHAR;i++){
      const icon = ICONS[(Math.random()*ICONS.length)|0];
      chars.push({
        id:i,
        x: rand(80, WORLD_W-80),
        y: rand(80, WORLD_H-80),
        alive:true,
        icon,
        seed: Math.random()*9999,
        scale: rand(0.90, 1.25),
        vx: rand(-22, 22),
        vy: rand(-16, 16),
        dance: 0
      });
    }
  }

  const stars = new Array(980).fill(0).map(()=>({
    x: Math.random()*WORLD_W,
    y: Math.random()*WORLD_H,
    r: Math.random()*1.6 + 0.25,
    a: Math.random()*0.8 + 0.15
  }));

  // Transforms
  function worldToScreen(wx, wy){
    const sx = (wx - cam.x) * zoom + (W/(2*DPR));
    const sy = (wy - cam.y) * zoom + (H/(2*DPR));
    return { x: sx*DPR + cam.shakeX, y: sy*DPR + cam.shakeY };
  }
  function screenToWorld(sx, sy){
    const wx = ((sx - cam.shakeX)/DPR - (W/(2*DPR))) / zoom + cam.x;
    const wy = ((sy - cam.shakeY)/DPR - (H/(2*DPR))) / zoom + cam.y;
    return { x: wx, y: wy };
  }

  // Input
  function setCursorFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (('clientX' in e) ? e.clientX : e.touches[0].clientX) - rect.left;
    const y = (('clientY' in e) ? e.clientY : e.touches[0].clientY) - rect.top;
    cursor.x = x * DPR;
    cursor.y = y * DPR;
  }
  canvas.addEventListener('contextmenu', (e)=>e.preventDefault());

  // Desktop
  canvas.addEventListener('mousemove', (e)=>setCursorFromEvent(e), { passive:true });
  canvas.addEventListener('mousedown', (e)=>{
    setCursorFromEvent(e);
    if(e.button===2){ toggleADS(); return; }
    if(e.button===0){ shoot(); return; }
  }, { passive:true });

  // Mobile: long press ADS, tap shoot, two-finger tap reload
  let pressTimer=null;
  canvas.addEventListener('touchstart', (e)=>{
    setCursorFromEvent(e);
    if(e.touches && e.touches.length>=2){ reload(); return; }
    pressTimer = setTimeout(()=>{ toggleADS(); pressTimer=null; }, 300);
  }, { passive:false });
  canvas.addEventListener('touchmove', (e)=>setCursorFromEvent(e), { passive:false });
  canvas.addEventListener('touchend', ()=>{
    if(pressTimer){
      clearTimeout(pressTimer);
      pressTimer=null;
      shoot();
    }
  }, { passive:false });

  addEventListener('keydown', (e)=>{
    const k=e.key.toLowerCase();
    if(k==='r') reload();
    if(k==='n') cycleVision();
    if(k==='escape') resetRound();
    if(e.key==='Shift') holdBreath=true;
  });
  addEventListener('keyup', (e)=>{
    if(e.key==='Shift') holdBreath=false;
  });

  resetBtn.addEventListener('click', resetRound);
  shuffleBtn.addEventListener('click', ()=>{
    spawn(); buildRoundTargets();
    tip("Crowd shuffled. Targets updated.", 1400);
  });
  visionBtn.addEventListener('click', cycleVision);

  function toggleADS(){
    scoped=!scoped;
    zoomTarget=scoped ? ZOOM_ON : ZOOM_OFF;
    adsTxt.textContent = `ADS: ${scoped ? "ON" : "OFF"}`;
    beep(scoped ? 520 : 420, 0.05, "sine", 0.04);
  }

  function cycleVision(){
    visionIndex = (visionIndex+1) % visionModes.length;
    visionBtn.textContent = `Vision: ${visionModes[visionIndex]}`;
    tip(`Vision: <b>${visionModes[visionIndex]}</b>`, 1000);
  }

  // Targets per round
  function quant(v, step){ return Math.round(v/step)*step; }

  function buildRoundTargets(){
    const alive=chars.filter(c=>c.alive);
    roundTargets=[];
    currentTargetIndex=0;
    const pool=alive.slice();
    for(let i=0;i<TARGETS_PER_ROUND && pool.length;i++){
      const idx=(Math.random()*pool.length)|0;
      roundTargets.push(pool[idx].id);
      pool.splice(idx,1);
    }
    updateObjectiveUI();
  }

  function currentTargetId(){ return roundTargets[currentTargetIndex] ?? null; }

  function updateObjectiveUI(){
    const id=currentTargetId();
    const t = (id===null) ? null : chars.find(c=>c.id===id && c.alive);
    if(!t){
      objTxt.textContent="—";
      hintTxt.textContent="—";
      leftTxt.textContent="0";
      return;
    }
    objTxt.textContent = t.icon.name;
    hintTxt.textContent = `X:${quant(t.x, 100)} Y:${quant(t.y, 100)}`;
    leftTxt.textContent = String(roundTargets.length - currentTargetIndex);
  }

  // UI updates
  function updateAmmoUI(){
    ammoTxt.textContent = `${mag} / ${reserve}`;
  }

  // Ballistics
  function calcTof(range){
    const t = range / MUZZLE_V;
    return clamp(t, 0.04, MAX_TOF);
  }
  function leadDotWorld(aimW, tof){
    const ws = effectiveWind();
    const drift = ws * tof * WIND_KT_TO_DRIFT;
    return { x: aimW.x + Math.cos(wind.dir)*drift, y: aimW.y + Math.sin(wind.dir)*drift };
  }

  // Aim assist: subtle MW “stickiness” only when ADS
  function getAimedWorldWithAssist(){
    const raw = screenToWorld(cursor.x, cursor.y);
    if(!scoped) return raw;

    let best=null, bestD=Infinity;
    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(raw.x, raw.y, c.x, c.y);
      if(d < AIM_ASSIST_RADIUS && d < bestD){ best=c; bestD=d; }
    }
    if(!best) return raw;

    // Breath hold makes it slightly stronger and steadier
    const strength = holdBreath ? (AIM_ASSIST_STRENGTH + 0.06) : AIM_ASSIST_STRENGTH;
    return { x: lerp(raw.x, best.x, strength), y: lerp(raw.y, best.y, strength) };
  }

  // Reload
  function reload(){
    if(reloading) return;
    if(mag >= MAG_SIZE){ beep(200,0.06,"square",0.04); return; }
    if(reserve <= 0){ tip("No reserve ammo.", 1000); beep(160,0.07,"square",0.04); return; }
    reloading = true;
    reloadUntil = performance.now() + RELOAD_MS;
    tip("Reloading…", 700);
    beep(280,0.05,"sine",0.04);
  }

  // Bullet visuals + hits
  const bullets=[];
  let hitMarkerUntil=0;

  function shoot(){
    if(reloading) return;

    if(mag <= 0){
      beep(120, 0.05, "square", 0.05);
      tip("Empty. Reload (R).", 900);
      return;
    }

    mag--;
    shots++;
    updateAmmoUI();

    cam.shakeX += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;
    cam.shakeY += (Math.random()*2-1) * SHAKE_ON_SHOT * DPR;

    const now = performance.now();
    const aimW = getAimedWorldWithAssist();

    const range = dist(aimW.x, aimW.y, cam.x, cam.y);
    const tof = calcTof(range);
    const impactW = leadDotWorld(aimW, tof);

    bullets.push({ t0: now, tof, aimW:{...aimW}, impactW, alive:true });

    // MW-ish gun pop (subtle)
    beep(920, 0.03, "square", 0.05);
    beep(240, 0.04, "sine", 0.03);

    // miss resets streak (MW feel)
    // (we’ll only reset when bullet resolves as miss)
  }

  function resolveBullet(b){
    let best=null, bestD=Infinity;

    // Headshot: treat top part of diamond as head zone
    // We model it simply: if impact is above center by a small amount, headshot.
    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(b.impactW.x, b.impactW.y, c.x, c.y);
      if(d < HIT_RADIUS && d < bestD){
        best=c; bestD=d;
      }
    }

    if(best){
      best.alive=false;
      kills++;
      streak++;

      const headshot = (b.impactW.y < best.y - 10);
      const base = 100;
      const hsBonus = headshot ? 75 : 0;
      const streakBonus = Math.min(80, streak*8);
      const earned = base + hsBonus + streakBonus;

      points += earned;

      const range = Math.round(dist(best.x, best.y, cam.x, cam.y));
      hitMarkerUntil = performance.now() + 140;

      showBanner(headshot ? "HEADSHOT" : "TARGET DOWN", `+${earned}  •  ${range}m`, 950);
      beep(1100, 0.05, "sine", 0.05);

      // objective check
      const tgtId=currentTargetId();
      if(tgtId !== null && best.id === tgtId){
        points += 150;
        tip(`Objective eliminated: <b>${best.icon.name}</b> (+150)`, 1300);
        currentTargetIndex++;
        if(currentTargetIndex >= roundTargets.length){
          tip(`<b>Round clear.</b>`, 1400);
          startNextRound();
        } else {
          updateObjectiveUI();
        }
      }
    } else {
      if(streak > 0) tip("Miss. Streak reset.", 950);
      streak = 0;
      beep(180, 0.06, "square", 0.04);
    }
  }

  // Wind
  function updateWind(now){
    wind.dir += Math.sin(now*0.00012) * 0.0007;
    if(!gust.active && Math.random() < 0.0016){
      gust.active=true;
      gust.extra=rand(1.5,4.2);
      gust.until=now + rand(900,1800);
    }
    if(gust.active && now >= gust.until){
      gust.active=false; gust.extra=0;
    }
  }

  // Background
  function drawBackground(){
    ctx.clearRect(0,0,W,H);
    const g = ctx.createRadialGradient(W*0.34,H*0.28, 10, W*0.34,H*0.28, Math.max(W,H)*0.92);
    g.addColorStop(0, 'rgba(16,26,85,1)');
    g.addColorStop(0.48,'rgba(7,10,20,1)');
    g.addColorStop(1,'rgba(5,6,11,1)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(const s of stars){
      const p = worldToScreen(s.x, s.y);
      if(p.x<-40||p.y<-40||p.x>W+40||p.y>H+40) continue;
      ctx.globalAlpha = s.a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s.r*DPR, 0, Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.fill();
    }
    ctx.restore();

    // very subtle grid
    ctx.save();
    ctx.globalAlpha=0.05;
    ctx.strokeStyle='rgba(255,255,255,1)';
    ctx.lineWidth=1*DPR;
    const grid=160;
    const tl = screenToWorld(0,0);
    const br = screenToWorld(W,H);
    const startX = Math.floor(tl.x/grid)*grid;
    const endX = Math.ceil(br.x/grid)*grid;
    const startY = Math.floor(tl.y/grid)*grid;
    const endY = Math.ceil(br.y/grid)*grid;
    for(let x=startX;x<=endX;x+=grid){
      const a=worldToScreen(x,startY), b=worldToScreen(x,endY);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    for(let y=startY;y<=endY;y+=grid){
      const a=worldToScreen(startX,y), b=worldToScreen(endX,y);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();
  }

  // Characters
  function updateAndDrawChars(now, aimW){
    let lock=null, lockD=1e9;
    const tgtId=currentTargetId();

    for(const c of chars){
      if(!c.alive) continue;

      // move
      c.x += c.vx * 0.016;
      c.y += c.vy * 0.016;
      if(c.x<80||c.x>WORLD_W-80) c.vx*=-1;
      if(c.y<80||c.y>WORLD_H-80) c.vy*=-1;
      c.x=clamp(c.x,80,WORLD_W-80);
      c.y=clamp(c.y,80,WORLD_H-80);

      // dance cue when ADS + near aim
      const d = dist(aimW.x, aimW.y, c.x, c.y);
      const wantDance = (scoped && d < DANCE_RADIUS) ? 1 : 0;
      c.dance += (wantDance - c.dance) * 0.20;

      // subtle “reaction” (MW: less silly)
      const phase = (now*0.007 + c.seed) % (Math.PI*2);
      const wig = c.dance * 6.5;
      const dx = Math.sin(phase*3.0) * wig;
      const dy = Math.cos(phase*2.2) * wig;
      const px = c.x + dx;
      const py = c.y + dy;

      if(scoped && d < DANCE_RADIUS && d < lockD){
        lock=c; lockD=d;
      }

      const p = worldToScreen(px, py);
      const size = CHAR_SIZE * c.scale * DPR * (0.88 + 0.12*zoom);

      ctx.save();
      ctx.translate(p.x, p.y);

      const hue = c.icon.hue;
      ctx.shadowColor = `hsla(${hue}, 90%, 65%, 0.52)`;
      ctx.shadowBlur = 12 * DPR;

      // diamond
      ctx.beginPath();
      ctx.moveTo(0, -size*1.35);
      ctx.lineTo(size*1.25, 0);
      ctx.lineTo(0, size*1.35);
      ctx.lineTo(-size*1.25, 0);
      ctx.closePath();
      ctx.fillStyle = `hsla(${hue}, 85%, 55%, 0.95)`;
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.lineWidth = 1.2*DPR;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.stroke();

      // glyph
      ctx.fillStyle='rgba(255,255,255,0.90)';
      ctx.font = `${Math.max(12, 14*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(c.icon.glyph, 0, 0);

      // When locked: small clean ring (MW cue)
      if(c.dance > 0.25){
        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = 'rgba(120,255,190,0.70)';
        ctx.lineWidth = 1.4*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*2.0, -0.55, 0.55);
        ctx.stroke();
      }

      // Objective ping only when not ADS (MW: don’t hold your hand)
      if(tgtId !== null && c.id === tgtId){
        ctx.globalAlpha = scoped ? 0.0 : 0.22;
        ctx.strokeStyle = 'rgba(255,210,90,0.95)';
        ctx.lineWidth = 2.1*DPR;
        ctx.beginPath();
        ctx.arc(0,0, size*2.35, 0, Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
    }
    return lock;
  }

  // Bullets
  function drawBullets(now){
    for(const b of bullets){
      if(!b.alive) continue;
      const age = (now - b.t0)/1000;
      const t = clamp(age / b.tof, 0, 1);
      const x = b.aimW.x + (b.impactW.x - b.aimW.x) * t;
      const y = b.aimW.y + (b.impactW.y - b.aimW.y) * t;

      const p = worldToScreen(x,y);
      const a = worldToScreen(b.aimW.x, b.aimW.y);

      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha=0.48;
      ctx.strokeStyle='rgba(255,255,255,1)';
      ctx.lineWidth=2.0*DPR;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(p.x,p.y); ctx.stroke();
      ctx.globalAlpha=0.85;
      ctx.fillStyle='rgba(255,255,255,1)';
      ctx.beginPath(); ctx.arc(p.x,p.y,2.5*DPR,0,Math.PI*2); ctx.fill();
      ctx.restore();

      if(age >= b.tof){
        b.alive=false;
        resolveBullet(b);
      }
    }
    for(let i=bullets.length-1;i>=0;i--) if(!bullets[i].alive) bullets.splice(i,1);
  }

  // Vision post
  function applyVisionPost(){
    const mode = visionModes[visionIndex];
    if(mode==="Normal") return;

    ctx.save();
    ctx.globalCompositeOperation='source-atop';

    if(mode==="Night Vision"){
      ctx.globalAlpha=0.20;
      ctx.fillStyle='rgb(40,255,120)';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=0.10;
      ctx.fillStyle='rgba(0,0,0,0.65)';
      for(let y=0;y<H;y+=6*DPR) ctx.fillRect(0,y,W,1*DPR);
    }

    if(mode==="Thermal"){
      ctx.globalAlpha=0.12;
      ctx.fillStyle='rgb(255,120,30)';
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=0.18;
      const g=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.18,W/2,H/2,Math.min(W,H)*0.72);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,'rgba(0,0,0,0.65)');
      ctx.fillStyle=g;
      ctx.fillRect(0,0,W,H);
    }

    ctx.restore();
  }

  // MW reticle/scope overlay (clean)
  function drawOverlay(now, lock){
    const cx = cursor.x, cy = cursor.y;

    if(!scoped){
      // Minimal MW crosshair
      ctx.save();
      ctx.globalAlpha=0.75;
      ctx.strokeStyle='rgba(235,240,255,0.70)';
      ctx.lineWidth=2.0*DPR;
      const L=14*DPR, G=6*DPR;
      ctx.beginPath();
      ctx.moveTo(cx-L, cy); ctx.lineTo(cx-G, cy);
      ctx.moveTo(cx+G, cy); ctx.lineTo(cx+L, cy);
      ctx.moveTo(cx, cy-L); ctx.lineTo(cx, cy-G);
      ctx.moveTo(cx, cy+G); ctx.lineTo(cx, cy+L);
      ctx.stroke();
      ctx.restore();
      return;
    }

    // Scope mask
    const r = (210 / Math.sqrt(zoom)) * DPR;

    ctx.save();
    ctx.globalAlpha=0.76;
    ctx.fillStyle='rgba(0,0,0,1)';
    ctx.fillRect(0,0,W,H);

    ctx.globalCompositeOperation='destination-out';
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation='source-over';

    // rim
    ctx.globalAlpha=1;
    ctx.lineWidth=3*DPR;
    ctx.strokeStyle='rgba(255,255,255,0.20)';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

    // reticle
    ctx.save();
    ctx.translate(cx,cy);
    ctx.strokeStyle = lock ? 'rgba(120,255,190,0.90)' : 'rgba(235,240,255,0.78)';
    ctx.lineWidth = 1.8*DPR;
    const L = r - 18*DPR;
    const G = 16*DPR;
    ctx.beginPath();
    ctx.moveTo(-L,0); ctx.lineTo(-G,0);
    ctx.moveTo(G,0);  ctx.lineTo(L,0);
    ctx.moveTo(0,-L); ctx.lineTo(0,-G);
    ctx.moveTo(0,G);  ctx.lineTo(0,L);
    ctx.stroke();

    ctx.fillStyle = lock ? 'rgba(120,255,190,0.98)' : 'rgba(235,240,255,0.88)';
    ctx.beginPath(); ctx.arc(0,0,2.2*DPR,0,Math.PI*2); ctx.fill();

    // MW hitmarker
    if(performance.now() <= hitMarkerUntil){
      ctx.strokeStyle='rgba(255,255,255,0.96)';
      ctx.lineWidth=2.3*DPR;
      const s=10*DPR;
      ctx.beginPath();
      ctx.moveTo(-s,-s); ctx.lineTo(s,s);
      ctx.moveTo(s,-s);  ctx.lineTo(-s,s);
      ctx.stroke();
    }

    ctx.restore();

    // slight glare
    ctx.globalAlpha=0.10;
    ctx.fillStyle='rgba(255,255,255,1)';
    ctx.beginPath();
    ctx.arc(cx-r*0.22, cy-r*0.22, r*0.42, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // Round control
  function startNextRound(){
    round++;
    roundTxt.textContent = String(round);
    timeLeft = ROUND_TIME_S;

    // small ammo reward
    reserve = Math.min(180, reserve + 30);
    mag = MAG_SIZE;
    reloading=false;

    // ensure enough alive characters
    if(chars.filter(c=>c.alive).length < 28) spawn();
    else for(const c of chars) if(Math.random() < 0.28) c.alive = true;

    buildRoundTargets();
    updateAmmoUI();

    tip(`<b>Round ${round}</b> — new objectives.`, 1300);
  }

  function resetRound(){
    round=1;
    timeLeft=ROUND_TIME_S;

    shots=0; kills=0; streak=0; points=0;
    mag=MAG_SIZE; reserve=RESERVE_START;
    reloading=false;

    wind.base = rand(7, 14);
    wind.dir = Math.random()*Math.PI*2;
    gust.active=false; gust.extra=0;

    scoped=false;
    zoom=ZOOM_OFF; zoomTarget=ZOOM_OFF;

    bullets.length=0;
    spawn();
    buildRoundTargets();
    updateAmmoUI();

    adsTxt.textContent="ADS: OFF";
    roundTxt.textContent="1";

    tip("Reset.", 900);
  }

  // MAIN LOOP
  let last = performance.now();
  function tick(now){
    const dt = Math.min(40, now-last);
    last = now;

    // finish reload
    if(reloading && now >= reloadUntil){
      const need = MAG_SIZE - mag;
      const take = Math.min(need, reserve);
      mag += take;
      reserve -= take;
      reloading=false;
      updateAmmoUI();
      beep(520, 0.05, "sine", 0.04);
      tip("Reload complete.", 900);
    }

    // timer
    timeLeft -= dt/1000;
    if(timeLeft <= 0){
      tip(`<b>Time.</b> Next round.`, 1200);
      streak=0;
      startNextRound();
    }
    timerTxt.textContent = `${Math.max(0,timeLeft).toFixed(1)}s`;

    // wind
    updateWind(now);
    windTxt.textContent = `${effectiveWind().toFixed(1)} kt`;

    // smooth zoom
    zoom += (zoomTarget - zoom) * ZOOM_SPEED;

    // aim (with assist)
    const aimW = getAimedWorldWithAssist();

    // MW sway: applied by moving cursor world slightly (visual only)
    const swayScale = holdBreath ? 0.35 : 1.0;
    const swayX = Math.sin(now*SWAY_SPEED) * SWAY_MAG * swayScale;
    const swayY = Math.cos(now*SWAY_SPEED*0.9) * SWAY_MAG * swayScale;
    aimW.x += swayX;
    aimW.y += swayY;

    // camera follow
    cam.x += (aimW.x - cam.x) * CAM_FOLLOW;
    cam.y += (aimW.y - cam.y) * CAM_FOLLOW;
    cam.x = clamp(cam.x, 200, WORLD_W-200);
    cam.y = clamp(cam.y, 200, WORLD_H-200);

    // shake decay
    cam.shakeX *= SHAKE_DECAY;
    cam.shakeY *= SHAKE_DECAY;

    // draw
    drawBackground();
    const lock = updateAndDrawChars(now, aimW);
    drawBullets(now);
    applyVisionPost();
    drawOverlay(now, lock);

    // range
    rangeTxt.textContent = `${Math.round(dist(aimW.x, aimW.y, cam.x, cam.y))} m`;

    // UI (lightweight)
    pointsTxt.textContent = String(points);
    killsTxt.textContent = String(kills);
    shotsTxt.textContent = String(shots);
    streakTxt.textContent = String(streak);
    leftTxt.textContent = String(Math.max(0, roundTargets.length - currentTargetIndex));
    updateObjectiveUI();

    requestAnimationFrame(tick);
  }

  // Init
  function init(){
    spawn();
    buildRoundTargets();
    updateAmmoUI();

    tip(`MW controls: <b>Right-click ADS</b>, <b>Left-click shoot</b>, <b>R reload</b>, <b>Shift hold breath</b>.`, 2600);
    requestAnimationFrame(tick);
  }

  // ADS toggle UI
  function setADSUI(){
    adsTxt.textContent = `ADS: ${scoped ? "ON" : "OFF"}`;
  }
  function toggleADS(){
    scoped=!scoped;
    zoomTarget=scoped ? ZOOM_ON : ZOOM_OFF;
    setADSUI();
    beep(scoped ? 520 : 420, 0.05, "sine", 0.04);
  }

  // Hook ADS function used earlier
  // (we already declared toggleADS below, but JS hoists — safe here)
  // Start
  init();

})();
</script>
</body>
</html>
