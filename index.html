<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Sea Farer — Scope Hunt (NV/Thermal + Breath + Gusts + Hit Calls)</title>
  <style>
    :root{
      --hud:#e9eefc;
      --hud2:#aab7ff;
      --ok:#75ffba;
      --bad:#ff6a6a;
      --warn:#ffcf5a;
      --glass: rgba(255,255,255,0.06);
      --line: rgba(255,255,255,0.18);
    }
    html,body{
      height:100%; margin:0; overflow:hidden;
      background: radial-gradient(1200px 800px at 30% 30%, #101a55 0%, #070a14 45%, #05060b 100%);
      color: var(--hud);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      user-select:none; -webkit-user-select:none;
      touch-action:none;
    }
    #wrap{ position:relative; width:100vw; height:100vh; }
    canvas{
      position:absolute; inset:0; width:100%; height:100%; display:block;
      background:
        radial-gradient(900px 700px at 70% 35%, rgba(152, 93, 255, 0.18), transparent 60%),
        radial-gradient(700px 600px at 25% 70%, rgba(64, 255, 213, 0.10), transparent 60%),
        radial-gradient(900px 900px at 40% 40%, rgba(255, 120, 200, 0.07), transparent 70%),
        radial-gradient(1200px 900px at 50% 50%, rgba(0,0,0,0.65), rgba(0,0,0,0.88));
    }

    .hud{
      position:absolute; left:16px; top:16px;
      display:flex; flex-direction:column; gap:10px;
      pointer-events:none; max-width: 420px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
    }
    .title{
      font-weight:800; letter-spacing:0.6px; font-size:12px;
      color: var(--hud2); text-transform: uppercase; margin-bottom:6px;
    }
    .row{ display:flex; justify-content:space-between; gap:12px; font-size:12px; line-height:1.35; }
    .row b{ color: var(--hud); }
    .hint{ font-size:12px; color: rgba(233,238,252,0.78); margin-top:8px; }

    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      font-size:12px; width:fit-content; margin-top:10px;
    }
    .dot{ width:8px; height:8px; border-radius:50%; background: var(--ok); box-shadow: 0 0 18px rgba(117,255,186,0.45); }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 18px rgba(255,106,106,0.45); }

    .barWrap{
      margin-top:10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.24);
      padding:8px 10px;
    }
    .barLabel{
      display:flex; justify-content:space-between;
      font-size:12px; color: rgba(233,238,252,0.82);
      margin-bottom:6px;
    }
    .bar{
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,0.08);
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.10);
    }
    .bar > div{
      height:100%;
      width:60%;
      background: rgba(117,255,186,0.75);
    }

    .toast{
      position:absolute; right:16px; top:16px;
      width:min(520px, calc(100vw - 32px));
      pointer-events:none;
      display:flex; flex-direction:column; gap:10px; align-items:flex-end;
    }
    .msg{
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      font-size:12px;
      color: rgba(233,238,252,0.88);
      max-width: 520px;
    }
    .msg b{ color: var(--warn); }

    .bottom{
      position:absolute; left:50%; transform:translateX(-50%); bottom:14px;
      width:min(980px, calc(100vw - 20px));
      pointer-events:none;
      display:flex; flex-direction:column; gap:8px;
    }
    .compass{
      height:46px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.28);
      backdrop-filter: blur(10px);
      overflow:hidden;
      display:flex; align-items:center;
      padding:0 12px; gap:12px;
    }
    .compass .label{
      font-size:12px;
      color: rgba(233,238,252,0.8);
      min-width:120px;
    }
    .strip{
      position:relative;
      flex:1;
      height:30px;
      border-radius:10px;
      background: linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.10);
      overflow:hidden;
    }
    .strip .ticks{
      position:absolute; inset:0;
      background-image: linear-gradient(to right, rgba(255,255,255,0.18) 1px, transparent 1px);
      background-size: 40px 100%;
      opacity:0.35;
    }
    .strip .ticks2{
      position:absolute; inset:0;
      background-image: linear-gradient(to right, rgba(255,255,255,0.22) 1px, transparent 1px);
      background-size: 200px 100%;
      opacity:0.35;
    }
    .strip .center{
      position:absolute; top:0; bottom:0; left:50%;
      width:2px;
      background: rgba(255,255,255,0.55);
      box-shadow: 0 0 14px rgba(255,255,255,0.20);
    }
    .strip .text{
      position:absolute; top:50%; transform: translateY(-50%);
      width:100%;
      display:flex;
      justify-content:space-between;
      padding:0 10px;
      font-size:11px;
      color: rgba(233,238,252,0.70);
      letter-spacing:0.4px;
    }

    .controls{
      position:absolute; right:16px; bottom:16px;
      width:min(520px, calc(100vw - 32px));
      pointer-events:auto;
    }
    button{
      appearance:none; border:none; cursor:pointer;
      border-radius:12px;
      padding:10px 12px;
      background: rgba(255,255,255,0.10);
      color: var(--hud);
      border: 1px solid rgba(255,255,255,0.14);
      font-weight:750;
      letter-spacing:0.2px;
    }
    button:hover{ background: rgba(255,255,255,0.14); }
    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .mini{ font-size:12px; opacity:0.92; color: rgba(233,238,252,0.80); }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.10);
      padding:2px 6px;
      border-radius:8px;
      color: rgba(233,238,252,0.92);
      white-space:nowrap;
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="panel">
      <div class="title">Sea Farer — Scope Hunt</div>

      <div class="row"><span>Mode</span><b id="modeTxt">Free Hunt</b></div>
      <div class="row"><span>Vision</span><b id="visionTxt">Normal</b></div>
      <div class="row"><span>Zoom</span><b id="zoomTxt">1×</b></div>

      <div class="row"><span>Targets Remaining</span><b id="remain">0</b></div>
      <div class="row"><span>Hits / Shots</span><b id="score">0 / 0</b></div>
      <div class="row"><span>Accuracy</span><b id="acc">0%</b></div>

      <div class="row"><span>Wind</span><b id="wind">0.0 kt</b></div>
      <div class="row"><span>Coordinates</span><b id="coord">X: 0  Y: 0</b></div>
      <div class="row"><span>Range</span><b id="range">0 m</b></div>
      <div class="row"><span>Flight Time</span><b id="tof">0.00 s</b></div>

      <div class="row"><span>Deck Sway</span><b id="swayTxt">ON</b></div>
      <div class="row"><span>Breath Hold</span><b id="breathTxt">READY</b></div>

      <div class="hint">
        <b>Keys:</b>
        <span class="kbd">Z</span> zoom •
        <span class="kbd">N</span> vision •
        <span class="kbd">M</span> missions •
        <span class="kbd">S</span> sway •
        <span class="kbd">H</span> hover assist •
        <span class="kbd">Shift</span> hold breath •
        <span class="kbd">R</span> reset
      </div>

      <div class="badge">
        <span class="dot bad" id="lockDot"></span>
        <span id="lockTxt">No lock</span>
      </div>

      <div class="barWrap">
        <div class="barLabel">
          <span>Breath Stamina</span>
          <b id="breathPct">100%</b>
        </div>
        <div class="bar"><div id="breathBar"></div></div>
      </div>

      <div class="panel" style="margin-top:10px;">
        <div class="title">Mission</div>
        <div class="row"><span>Objective</span><b id="missionTitle">—</b></div>
        <div class="row"><span>Hint</span><b id="missionHint">—</b></div>
        <div class="row"><span>Progress</span><b id="missionProg">—</b></div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="bottom">
    <div class="compass">
      <div class="label">Compass / Bearing</div>
      <div class="strip">
        <div class="ticks"></div>
        <div class="ticks2"></div>
        <div class="center"></div>
        <div class="text">
          <span>W</span><span>NW</span><span>N</span><span>NE</span><span>E</span>
        </div>
      </div>
      <div class="label" style="text-align:right;">
        Bearing: <b id="bearing">000°</b>
      </div>
    </div>
  </div>

  <div class="controls">
    <div class="panel">
      <div class="title">Quick Controls</div>
      <div class="mini">
        <b>Mouse/Trackpad:</b> move to aim • click/tap to fire<br/>
        <b>Extras:</b> In Missions mode, you should shoot the correct target (near the hinted coordinates).
      </div>
      <div class="btnRow" style="margin-top:10px;">
        <button id="resetBtn">Reset Round</button>
        <button id="shuffleBtn">Shuffle Crowd</button>
        <button id="assistBtn">Hover Assist: ON</button>
        <button id="zoomBtn">Zoom: 1×</button>
        <button id="visionBtn">Vision: Normal</button>
        <button id="missionBtn">Missions: OFF</button>
        <button id="swayBtn">Sway: ON</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  const uiRemain = document.getElementById('remain');
  const uiScore  = document.getElementById('score');
  const uiAcc    = document.getElementById('acc');
  const uiWind   = document.getElementById('wind');
  const uiCoord  = document.getElementById('coord');
  const uiRange  = document.getElementById('range');
  const uiTof    = document.getElementById('tof');
  const uiBearing= document.getElementById('bearing');
  const uiZoom   = document.getElementById('zoomTxt');
  const uiMode   = document.getElementById('modeTxt');
  const uiSway   = document.getElementById('swayTxt');

  const uiVision = document.getElementById('visionTxt');

  const uiBreathTxt = document.getElementById('breathTxt');
  const uiBreathPct = document.getElementById('breathPct');
  const uiBreathBar = document.getElementById('breathBar');

  const uiMissionTitle = document.getElementById('missionTitle');
  const uiMissionHint  = document.getElementById('missionHint');
  const uiMissionProg  = document.getElementById('missionProg');

  const lockDot  = document.getElementById('lockDot');
  const lockTxt  = document.getElementById('lockTxt');
  const toastEl  = document.getElementById('toast');

  const resetBtn  = document.getElementById('resetBtn');
  const shuffleBtn= document.getElementById('shuffleBtn');
  const assistBtn = document.getElementById('assistBtn');
  const zoomBtn   = document.getElementById('zoomBtn');
  const visionBtn = document.getElementById('visionBtn');
  const missionBtn= document.getElementById('missionBtn');
  const swayBtn   = document.getElementById('swayBtn');

  // World
  const WORLD_W = 2400;
  const WORLD_H = 1600;
  const NUM_CHAR = 100;

  // Small targets
  const CHAR_SIZE = 10;
  const HIT_RADIUS = 16;
  const HOVER_RADIUS = 52;
  const DANCE_STRENGTH = 6.0;

  // Ballistics feel
  const MUZZLE_V = 650;
  const MAX_TOF  = 1.25;
  const WIND_KT_TO_DRIFT = 0.45;

  // Scope & shake
  const SCOPE_RADIUS_PX_BASE = 170;
  const CROSS_GAP = 14;
  const SHAKE_ON_SHOT = 10;
  const SHAKE_DECAY = 0.90;

  // Zoom
  const zoomLevels = [1, 2, 4];
  let zoomIndex = 0;
  let zoom = zoomLevels[zoomIndex];

  // Vision modes
  const visionModes = ["Normal", "Night Vision", "Thermal"];
  let visionIndex = 0;

  // Canvas scale
  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener('resize', resize);
  resize();

  // Camera
  const cam = {
    x: WORLD_W/2,
    y: WORLD_H/2,
    shakeX: 0,
    shakeY: 0,
  };

  // Deck sway
  let swayOn = true;
  const sway = { a: 10, b: 7, s1: 0.0019, s2: 0.0026 };

  // Breath hold system
  let holdingBreath = false;
  let breath = 1.0;            // 0..1
  const breathDrain = 0.25;    // per second
  const breathRegen = 0.18;    // per second
  const breathMinToHold = 0.10;

  // Assist & modes
  let hoverAssist = true;
  let missionsOn = false;

  // Stats
  let shots=0, hits=0;

  // Wind + gusts
  const wind = { speed: 8 + Math.random()*14, dir: Math.random()*Math.PI*2 };
  let gust = {
    active: false,
    until: 0,
    extra: 0,
    msgCooldown: 0
  };

  // Cursor (screen device coords)
  const cursor = { x: W/2, y: H/2 };

  // Targets
  const ICONS = [
    { name:"Pika-ish",   glyph:"⚡", hue: 52 },
    { name:"DBZ-ish",    glyph:"✦", hue: 40 },
    { name:"Fighter",    glyph:"✊", hue: 10 },
    { name:"Sponge-ish", glyph:"▦", hue: 58 },
    { name:"Alien",      glyph:"⬡", hue: 190 },
    { name:"Bot",        glyph:"⬢", hue: 210 },
    { name:"Star",       glyph:"✶", hue: 300 },
    { name:"Skull",      glyph:"☠", hue: 350 },
  ];

  function rand(min,max){ return min + Math.random()*(max-min); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

  let chars = [];
  function spawnCharacters(){
    chars = [];
    for(let i=0;i<NUM_CHAR;i++){
      const icon = ICONS[(Math.random()*ICONS.length)|0];
      chars.push({
        id:i,
        x: rand(80, WORLD_W-80),
        y: rand(80, WORLD_H-80),
        baseX: 0,
        baseY: 0,
        alive: true,
        icon,
        seed: Math.random()*9999,
        bob: rand(0.6, 1.6),
        scale: rand(0.85, 1.15),
        dance: 0,
        hitFlash: 0,
        vx: rand(-18, 18),
        vy: rand(-14, 14)
      });
    }
    for(const c of chars){ c.baseX=c.x; c.baseY=c.y; }
  }
  spawnCharacters();

  // Stars
  const stars = new Array(820).fill(0).map(()=>({
    x: Math.random()*WORLD_W,
    y: Math.random()*WORLD_H,
    r: Math.random()*1.7 + 0.2,
    a: Math.random()*0.8 + 0.15
  }));

  // Toast
  function toast(html, ms=1600){
    const div = document.createElement('div');
    div.className = 'msg';
    div.innerHTML = html;
    toastEl.appendChild(div);
    setTimeout(()=>{
      div.style.transition = 'opacity 260ms ease, transform 260ms ease';
      div.style.opacity = '0';
      div.style.transform = 'translateY(-6px)';
      setTimeout(()=>div.remove(), 320);
    }, ms);
  }

  // --- Zoom-aware transforms ---
  function viewHalfW(){ return (W/(2*DPR))/zoom; }
  function viewHalfH(){ return (H/(2*DPR))/zoom; }

  function worldToScreen(wx, wy){
    const sx = (wx - cam.x) * zoom + (W/(2*DPR));
    const sy = (wy - cam.y) * zoom + (H/(2*DPR));
    return { x: sx*DPR + cam.shakeX, y: sy*DPR + cam.shakeY };
  }
  function screenToWorld(sx, sy){
    const wx = ((sx - cam.shakeX)/DPR - (W/(2*DPR))) / zoom + cam.x;
    const wy = ((sy - cam.shakeY)/DPR - (H/(2*DPR))) / zoom + cam.y;
    return { x: wx, y: wy };
  }

  // Input
  function setCursorFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (('clientX' in e) ? e.clientX : e.touches[0].clientX) - rect.left;
    const y = (('clientY' in e) ? e.clientY : e.touches[0].clientY) - rect.top;
    cursor.x = x * DPR;
    cursor.y = y * DPR;
  }
  canvas.addEventListener('mousemove', (e)=>setCursorFromEvent(e), { passive:true });
  canvas.addEventListener('mousedown', (e)=>{ setCursorFromEvent(e); fire(); }, { passive:true });
  canvas.addEventListener('touchstart', (e)=>{ setCursorFromEvent(e); fire(); }, { passive:false });
  canvas.addEventListener('touchmove', (e)=>{ setCursorFromEvent(e); }, { passive:false });

  addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='r') resetRound();
    if(k==='h') toggleAssist();
    if(k==='z') cycleZoom();
    if(k==='m') toggleMissions();
    if(k==='s') toggleSway();
    if(k==='n') cycleVision();
    if(e.key === 'Shift') holdingBreath = true;
  });
  addEventListener('keyup', (e)=>{
    if(e.key === 'Shift') holdingBreath = false;
  });

  resetBtn.addEventListener('click', resetRound);
  shuffleBtn.addEventListener('click', ()=>{ spawnCharacters(); buildMissions(); toast("Shuffled the galaxy crowd."); });
  assistBtn.addEventListener('click', toggleAssist);
  zoomBtn.addEventListener('click', cycleZoom);
  visionBtn.addEventListener('click', cycleVision);
  missionBtn.addEventListener('click', toggleMissions);
  swayBtn.addEventListener('click', toggleSway);

  function toggleAssist(){
    hoverAssist = !hoverAssist;
    assistBtn.textContent = `Hover Assist: ${hoverAssist ? 'ON' : 'OFF'}`;
    toast(`Hover Assist <b>${hoverAssist ? 'ON' : 'OFF'}</b>`);
  }
  function cycleZoom(){
    zoomIndex = (zoomIndex+1) % zoomLevels.length;
    zoom = zoomLevels[zoomIndex];
    uiZoom.textContent = `${zoom}×`;
    zoomBtn.textContent = `Zoom: ${zoom}×`;
    toast(`Zoom set to <b>${zoom}×</b>`);
  }
  function cycleVision(){
    visionIndex = (visionIndex+1) % visionModes.length;
    const v = visionModes[visionIndex];
    uiVision.textContent = v;
    visionBtn.textContent = `Vision: ${v}`;
    toast(`Vision: <b>${v}</b>`);
  }
  function toggleMissions(){
    missionsOn = !missionsOn;
    uiMode.textContent = missionsOn ? "Missions" : "Free Hunt";
    missionBtn.textContent = `Missions: ${missionsOn ? 'ON' : 'OFF'}`;
    toast(`Missions <b>${missionsOn ? 'ON' : 'OFF'}</b>`);
    if(missionsOn && missions.length===0) buildMissions();
    if(!missionsOn) renderMissionUI();
  }
  function toggleSway(){
    swayOn = !swayOn;
    uiSway.textContent = swayOn ? "ON" : "OFF";
    swayBtn.textContent = `Sway: ${swayOn ? 'ON' : 'OFF'}`;
    toast(`Deck Sway <b>${swayOn ? 'ON' : 'OFF'}</b>`);
  }

  function resetRound(){
    shots=0; hits=0;
    wind.speed = 8 + Math.random()*14;
    wind.dir = Math.random() * Math.PI * 2;
    gust.active = false; gust.until = 0; gust.extra = 0; gust.msgCooldown = 0;
    spawnCharacters();
    bullets.length = 0;
    buildMissions();
    cam.shakeX = 0; cam.shakeY = 0;
    breath = 1.0; holdingBreath = false;
    toast("New round. New wind. New chaos.");
    updateHUD(null, 0, 0);
  }

  // Missions
  let missions = [];
  let missionIndex = 0;
  function quantize(v, step){ return Math.round(v/step)*step; }

  function buildMissions(){
    missions = [];
    missionIndex = 0;
    const alive = chars.filter(c=>c.alive);
    const pickCount = Math.min(5, alive.length);
    for(let i=0;i<pickCount;i++){
      const t = alive.splice((Math.random()*alive.length)|0, 1)[0];
      missions.push({
        targetId: t.id,
        name: t.icon.name,
        hintX: quantize(t.baseX, 50),
        hintY: quantize(t.baseY, 50)
      });
    }
    renderMissionUI();
  }

  function currentMission(){
    if(!missionsOn || missions.length===0) return null;
    return missions[missionIndex] || null;
  }

  function renderMissionUI(){
    const m = currentMission();
    if(!missionsOn || !m){
      uiMissionTitle.textContent = missionsOn ? "No missions" : "—";
      uiMissionHint.textContent = missionsOn ? "Press Shuffle/Reset" : "—";
      uiMissionProg.textContent = "—";
      return;
    }
    uiMissionTitle.textContent = `Find & shoot: ${m.name}`;
    uiMissionHint.textContent  = `Near X:${m.hintX}  Y:${m.hintY}`;
    uiMissionProg.textContent  = `${missionIndex+1} / ${missions.length}`;
  }

  // Gust engine
  function updateGust(now, dt){
    gust.msgCooldown = Math.max(0, gust.msgCooldown - dt);

    // small natural wind wander
    wind.speed = clamp(wind.speed + (Math.sin(now*0.00025)*0.002) * dt * 60, 4, 28);

    // trigger gust occasionally
    if(!gust.active && Math.random() < 0.0022){
      gust.active = true;
      gust.extra = rand(4, 12);
      gust.until = now + rand(1400, 3200);
      if(gust.msgCooldown <= 0){
        toast(`Gust incoming: <b>+${gust.extra.toFixed(1)} kt</b>`, 1600);
        gust.msgCooldown = 1400;
      }
    }

    if(gust.active){
      if(now >= gust.until){
        gust.active = false;
        gust.extra = 0;
        if(gust.msgCooldown <= 0){
          toast(`Gust faded.`, 1100);
          gust.msgCooldown = 1200;
        }
      }
    }
  }

  function effectiveWindSpeed(){
    return wind.speed + (gust.active ? gust.extra : 0);
  }

  // Ballistics helpers
  const bullets = [];
  function calcTof(range){
    const t = range / MUZZLE_V;
    return clamp(t, 0.04, MAX_TOF);
  }

  function leadDotWorld(aimW, tof){
    const ws = effectiveWindSpeed();
    const drift = ws * tof * WIND_KT_TO_DRIFT;
    return {
      x: aimW.x + Math.cos(wind.dir) * drift,
      y: aimW.y + Math.sin(wind.dir) * drift
    };
  }

  // Hit marker (in-scope)
  let hitMarker = { on:false, until:0, x:0, y:0 };

  function setHitMarker(screenX, screenY){
    hitMarker.on = true;
    hitMarker.until = performance.now() + 150; // short “X”
    hitMarker.x = screenX;
    hitMarker.y = screenY;
  }

  function fire(){
    shots++;
    cam.shakeX += (Math.random()*2 - 1) * SHAKE_ON_SHOT * DPR;
    cam.shakeY += (Math.random()*2 - 1) * SHAKE_ON_SHOT * DPR;

    const now = performance.now();
    const aimW = getEffectiveAimWorld(now);
    const range = dist(aimW.x, aimW.y, cam.x, cam.y);
    const tof = calcTof(range);
    const impactW = leadDotWorld(aimW, tof);

    bullets.push({
      t0: now,
      tof,
      aimW: { ...aimW },
      impactW,
      alive: true
    });

    updateHUD(null, range, tof);
  }

  function resolveBullet(b){
    let best=null, bestD=Infinity;

    for(const c of chars){
      if(!c.alive) continue;
      const d = dist(b.impactW.x, b.impactW.y, c.x, c.y);
      if(d < HIT_RADIUS && d < bestD){
        best=c; bestD=d;
      }
    }

    if(best){
      const range = Math.round(dist(best.x, best.y, cam.x, cam.y));
      // hit marker at center of scope (true aim)
      const impactS = worldToScreen(best.x, best.y);
      setHitMarker(impactS.x, impactS.y);

      const m = currentMission();
      if(m){
        if(best.id === m.targetId){
          best.alive=false; best.hitFlash=1.0;
          hits++;
          toast(`Target down, <b>${range}m</b>. Mission confirmed.`, 1800);
          missionIndex++;
          if(missionIndex >= missions.length){
            toast(`Missions cleared. Accuracy: <b>${shots ? Math.round((hits/shots)*100) : 0}%</b>`, 2400);
          }
          renderMissionUI();
        } else {
          best.alive=false; best.hitFlash=1.0;
          hits++;
          toast(`Target down, <b>${range}m</b>. Wrong mission target.`, 2000);
        }
      } else {
        best.alive=false; best.hitFlash=1.0;
        hits++;
        toast(`Target down, <b>${range}m</b>.`, 1500);
      }
    } else {
      toast(`Miss. Wind: <b>${effectiveWindSpeed().toFixed(1)} kt</b>`, 1200);
    }
  }

  // HUD
  function updateHUD(lockedTarget=null, range=0, tof=0){
    const remaining = chars.filter(c=>c.alive).length;
    uiRemain.textContent = remaining;

    uiScore.textContent = `${hits} / ${shots}`;
    const acc = shots ? Math.round((hits/shots)*100) : 0;
    uiAcc.textContent = `${acc}%`;

    uiWind.textContent = `${effectiveWindSpeed().toFixed(1)} kt`;
    uiZoom.textContent = `${zoom}×`;
    uiSway.textContent = swayOn ? "ON" : "OFF";
    uiVision.textContent = visionModes[visionIndex];

    if(lockedTarget){
      lockDot.classList.remove('bad');
      lockTxt.textContent = `LOCK: ${lockedTarget.icon.name}`;
    } else {
      lockDot.classList.add('bad');
      lockTxt.textContent = `No lock`;
    }

    if(range){
      uiRange.textContent = `${Math.round(range)} m`;
    }
    if(tof){
      uiTof.textContent = `${tof.toFixed(2)} s`;
    }
  }

  // Vision effects
  function applyVisionPost(){
    const mode = visionModes[visionIndex];

    if(mode === "Normal") return;

    ctx.save();
    ctx.globalCompositeOperation = 'source-atop';

    if(mode === "Night Vision"){
      // green wash + slight noise
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = 'rgb(40,255,120)';
      ctx.fillRect(0,0,W,H);

      // vignette edges
      ctx.globalAlpha = 0.25;
      const g = ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.15, W/2,H/2, Math.min(W,H)*0.62);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,'rgba(0,0,0,0.55)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // scanlines
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      for(let y=0;y<H;y+=6*DPR){
        ctx.fillRect(0,y,W,1*DPR);
      }
    }

    if(mode === "Thermal"){
      // thermal overlay: warm tint + contrast impression
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = 'rgb(255,120,30)';
      ctx.fillRect(0,0,W,H);

      // cool vignette
      ctx.globalAlpha = 0.22;
      const g2 = ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.14, W/2,H/2, Math.min(W,H)*0.64);
      g2.addColorStop(0,'rgba(0,0,0,0)');
      g2.addColorStop(1,'rgba(0,0,0,0.65)');
      ctx.fillStyle = g2;
      ctx.fillRect(0,0,W,H);
    }

    ctx.restore();
  }

  // Background
  function drawBackground(now){
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for(const s of stars){
      const p = worldToScreen(s.x, s.y);
      if(p.x<-50||p.y<-50||p.x>W+50||p.y>H+50) continue;
      ctx.globalAlpha = s.a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s.r*DPR, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,1)';
      ctx.fill();
    }
    ctx.restore();

    // nav grid
    ctx.save();
    ctx.globalAlpha = 0.07;
    ctx.strokeStyle = 'rgba(255,255,255,1)';
    ctx.lineWidth = 1*DPR;

    const grid = 120;
    const tl = screenToWorld(0,0);
    const br = screenToWorld(W,H);
    const startX = Math.floor(tl.x / grid) * grid;
    const endX   = Math.ceil(br.x / grid) * grid;
    const startY = Math.floor(tl.y / grid) * grid;
    const endY   = Math.ceil(br.y / grid) * grid;

    for(let x=startX; x<=endX; x+=grid){
      const a = worldToScreen(x, startY);
      const b = worldToScreen(x, endY);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    for(let y=startY; y<=endY; y+=grid){
      const a = worldToScreen(startX, y);
      const b = worldToScreen(endX, y);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();
  }

  // Aim sway + breath hold steady
  function getSwayOffset(now){
    if(!swayOn) return { x:0, y:0 };

    // base sway
    let ox = Math.sin(now*sway.s1) * sway.a * DPR;
    let oy = Math.cos(now*sway.s2) * sway.b * DPR;

    // gust increases sway a bit
    const g = gust.active ? (gust.extra / 12) : 0;
    ox *= (1 + g*0.35);
    oy *= (1 + g*0.35);

    // breath hold reduces sway if stamina allows
    const canHold = holdingBreath && breath > breathMinToHold;
    if(canHold){
      ox *= 0.35;
      oy *= 0.35;
    }
    return { x: ox, y: oy };
  }

  function getEffectiveAimWorld(now){
    const sw = getSwayOffset(now);
    const sx = cursor.x + sw.x;
    const sy = cursor.y + sw.y;
    return screenToWorld(sx, sy);
  }

  // Characters
  function drawCharacters(now, aimW){
    let locked=null, best=Infinity;

    for(const c of chars){
      if(!c.alive) continue;

      // drift
      const dt = 0.016;
      c.baseX += c.vx * dt;
      c.baseY += c.vy * dt;

      if(c.baseX < 80 || c.baseX > WORLD_W-80) c.vx *= -1;
      if(c.baseY < 80 || c.baseY > WORLD_H-80) c.vy *= -1;
      c.baseX = clamp(c.baseX, 80, WORLD_W-80);
      c.baseY = clamp(c.baseY, 80, WORLD_H-80);

      const d = dist(aimW.x, aimW.y, c.x, c.y);
      const danceTrigger = hoverAssist ? (d < HOVER_RADIUS*1.25) : (d < HOVER_RADIUS);
      c.dance += ((danceTrigger?1:0) - c.dance) * 0.15;

      const phase = (now*0.006*c.bob + c.seed) % (Math.PI*2);
      const wigX = Math.sin(phase*2.4) * DANCE_STRENGTH * c.dance;
      const wigY = Math.cos(phase*2.0) * DANCE_STRENGTH * c.dance;
      const idle = Math.sin(phase) * 1.5;

      c.x = c.baseX + wigX;
      c.y = c.baseY + wigY + idle;

      if(d < HOVER_RADIUS && d < best){
        best = d; locked = c;
      }
    }

    // draw
    for(const c of chars){
      if(!c.alive && c.hitFlash <= 0.01) continue;

      const p = worldToScreen(c.x, c.y);
      if(p.x<-80||p.y<-80||p.x>W+80||p.y>H+80) continue;

      const size = CHAR_SIZE * c.scale * DPR * zoom;
      c.hitFlash *= 0.88;

      const alpha = c.alive ? 1 : Math.max(0, c.hitFlash);

      ctx.save();
      ctx.globalAlpha = alpha;

      let hue = c.icon.hue;
      // thermal bias makes “hot” items pop a bit warmer
      if(visionModes[visionIndex] === "Thermal"){
        hue = clamp(hue + 10, 0, 360);
      }

      ctx.shadowColor = `hsla(${hue}, 90%, 65%, 0.65)`;
      ctx.shadowBlur = 14 * DPR;

      ctx.translate(p.x, p.y);
      const rot = (Math.sin((now*0.008)+c.seed)*0.12) * c.dance;
      ctx.rotate(rot);

      ctx.beginPath();
      ctx.moveTo(0, -size*1.2);
      ctx.lineTo(size*1.1, 0);
      ctx.lineTo(0, size*1.2);
      ctx.lineTo(-size*1.1, 0);
      ctx.closePath();
      ctx.fillStyle = `hsla(${hue}, 85%, 55%, 0.95)`;
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.lineWidth = 1.2 * DPR;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.stroke();

      ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = 'rgba(255,255,255,0.86)';
      ctx.font = `${Math.max(10, 12*DPR)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(c.icon.glyph, 0, 0);

      if(c.dance > 0.2 && c.alive){
        ctx.globalAlpha = alpha * 0.75;
        ctx.strokeStyle = `hsla(${hue}, 90%, 70%, 0.7)`;
        ctx.lineWidth = 1.2*DPR;
        ctx.beginPath();
        ctx.arc(0, 0, size*1.55, -0.4, 0.4);
        ctx.stroke();
      }

      ctx.restore();
    }

    updateHUD(locked, 0, 0);
    return locked;
  }

  // Ballistics helpers
  function drawBallisticHelpers(now, aimW){
    const range = dist(aimW.x, aimW.y, cam.x, cam.y);
    const tof = calcTof(range);

    uiCoord.textContent = `X: ${Math.round(aimW.x)}  Y: ${Math.round(aimW.y)}`;
    uiRange.textContent = `${Math.round(range)} m`;
    uiTof.textContent   = `${tof.toFixed(2)} s`;

    let ang = Math.atan2(aimW.y - cam.y, aimW.x - cam.x);
    let deg = (90 - (ang * 180/Math.PI));
    deg = (deg % 360 + 360) % 360;
    uiBearing.textContent = `${String(Math.round(deg)).padStart(3,'0')}°`;

    // lead / impact dot
    const impactW = leadDotWorld(aimW, tof);
    const impactS = worldToScreen(impactW.x, impactW.y);

    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.fillStyle   = 'rgba(255,255,255,0.85)';
    ctx.lineWidth   = 1.4*DPR;

    ctx.beginPath();
    ctx.arc(impactS.x, impactS.y, 3.0*DPR, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.arc(impactS.x, impactS.y, 11.0*DPR, 0, Math.PI*2);
    ctx.stroke();

    // faint vector
    const aimS = worldToScreen(aimW.x, aimW.y);
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    ctx.moveTo(aimS.x, aimS.y);
    ctx.lineTo(impactS.x, impactS.y);
    ctx.stroke();

    ctx.restore();

    return { range, tof, impactW };
  }

  // Bullets/tracers
  function drawBullets(now){
    for(const b of bullets){
      if(!b.alive) continue;
      const age = (now - b.t0) / 1000;
      const t = clamp(age / b.tof, 0, 1);

      const x = b.aimW.x + (b.impactW.x - b.aimW.x) * t;
      const y = b.aimW.y + (b.impactW.y - b.aimW.y) * t;

      const p = worldToScreen(x, y);
      const a = worldToScreen(b.aimW.x, b.aimW.y);

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(255,255,255,1)';
      ctx.lineWidth = 2.0*DPR;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();

      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.6*DPR, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,1)';
      ctx.fill();
      ctx.restore();

      if(age >= b.tof){
        b.alive = false;
        resolveBullet(b);
      }
    }
    for(let i=bullets.length-1;i>=0;i--){
      if(!bullets[i].alive) bullets.splice(i,1);
    }
  }

  // Scope overlay (with sway + hit marker)
  function drawScopeOverlay(now, lockedTarget){
    const swayOff = getSwayOffset(now);

    const cx = cursor.x, cy = cursor.y;
    const aimCx = cursor.x + swayOff.x;
    const aimCy = cursor.y + swayOff.y;

    const r = (SCOPE_RADIUS_PX_BASE / Math.sqrt(zoom)) * DPR;

    ctx.save();

    // Outside darkness
    ctx.globalAlpha = 0.78;
    ctx.fillStyle = 'rgba(0,0,0,1)';
    ctx.fillRect(0,0,W,H);

    // Punch scope hole
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';

    // Scope rim
    ctx.globalAlpha = 1;
    ctx.lineWidth = 3.0*DPR;
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.stroke();

    ctx.lineWidth = 1.2*DPR;
    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.arc(cx, cy, r-3*DPR, 0, Math.PI*2);
    ctx.stroke();

    // Reticle at true aim (sway included)
    ctx.save();
    ctx.translate(aimCx, aimCy);

    const L = r - 16*DPR;
    const G = CROSS_GAP * DPR;

    ctx.strokeStyle = lockedTarget ? 'rgba(117,255,186,0.85)' : 'rgba(233,238,252,0.78)';
    ctx.lineWidth = (1.6 * DPR) / Math.max(1, Math.sqrt(zoom));

    ctx.beginPath();
    ctx.moveTo(-L, 0); ctx.lineTo(-G, 0);
    ctx.moveTo(G, 0);  ctx.lineTo(L, 0);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, -L); ctx.lineTo(0, -G);
    ctx.moveTo(0, G);  ctx.lineTo(0, L);
    ctx.stroke();

    ctx.fillStyle = lockedTarget ? 'rgba(117,255,186,0.95)' : 'rgba(233,238,252,0.85)';
    ctx.beginPath();
    ctx.arc(0,0, 2.2*DPR, 0, Math.PI*2);
    ctx.fill();

    if(lockedTarget){
      ctx.strokeStyle = 'rgba(117,255,186,0.85)';
      ctx.lineWidth = 1.6*DPR;
      const b = 16*DPR, d = 38*DPR;
      ctx.beginPath();
      ctx.moveTo(-d, -d+b); ctx.lineTo(-d, -d); ctx.lineTo(-d+b, -d);
      ctx.moveTo(d-b, -d);  ctx.lineTo(d, -d);  ctx.lineTo(d, -d+b);
      ctx.moveTo(d, d-b);   ctx.lineTo(d, d);   ctx.lineTo(d-b, d);
      ctx.moveTo(-d+b, d);  ctx.lineTo(-d, d);  ctx.lineTo(-d, d-b);
      ctx.stroke();
    }

    ctx.restore();

    // Hit marker overlay inside scope
    if(hitMarker.on && now <= hitMarker.until){
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.strokeStyle = 'rgba(255,255,255,0.92)';
      ctx.lineWidth = 2.0*DPR;

      // draw an "X" centered at aim point (feels like hit confirm)
      ctx.translate(aimCx, aimCy);
      const s = 10*DPR;
      ctx.beginPath();
      ctx.moveTo(-s,-s); ctx.lineTo(s,s);
      ctx.moveTo(s,-s);  ctx.lineTo(-s,s);
      ctx.stroke();
      ctx.restore();
    } else {
      hitMarker.on = false;
    }

    // Glass glare
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.beginPath();
    ctx.arc(cx - r*0.22, cy - r*0.22, r*0.42, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.restore();
  }

  // Breath update
  function updateBreath(dt){
    const canHold = holdingBreath && breath > breathMinToHold;

    if(canHold){
      breath = Math.max(0, breath - breathDrain * (dt/1000));
      uiBreathTxt.textContent = "HOLDING";
    } else {
      breath = Math.min(1, breath + breathRegen * (dt/1000));
      uiBreathTxt.textContent = (breath > breathMinToHold) ? "READY" : "RECOVERING";
    }

    const pct = Math.round(breath*100);
    uiBreathPct.textContent = `${pct}%`;
    uiBreathBar.style.width = `${pct}%`;

    // change bar tint by stamina (without hardcoding too much)
    if(pct < 20){
      uiBreathBar.style.background = 'rgba(255,106,106,0.75)';
    } else if(pct < 45){
      uiBreathBar.style.background = 'rgba(255,207,90,0.75)';
    } else {
      uiBreathBar.style.background = 'rgba(117,255,186,0.75)';
    }
  }

  // Main loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min(40, now-last);
    last = now;

    // update gusts and breath
    updateGust(now, dt);
    updateBreath(dt);

    // decay camera shake
    cam.shakeX *= SHAKE_DECAY;
    cam.shakeY *= SHAKE_DECAY;

    // keep camera in bounds (zoom-aware)
    cam.x = clamp(cam.x, viewHalfW(), WORLD_W - viewHalfW());
    cam.y = clamp(cam.y, viewHalfH(), WORLD_H - viewHalfH());

    ctx.clearRect(0,0,W,H);

    const aimW = getEffectiveAimWorld(now);

    drawBackground(now);

    // wind vector in view
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = 'rgba(255,255,255,1)';
    ctx.lineWidth = 2*DPR;
    const base = worldToScreen(cam.x - viewHalfW() + 90, cam.y - viewHalfH() + 90);
    const ws = effectiveWindSpeed();
    const len = (ws/28) * 80 * DPR;
    ctx.beginPath();
    ctx.moveTo(base.x, base.y);
    ctx.lineTo(base.x + Math.cos(wind.dir)*len, base.y + Math.sin(wind.dir)*len);
    ctx.stroke();
    ctx.restore();

    const locked = drawCharacters(now, aimW);

    const bh = drawBallisticHelpers(now, aimW);
    updateHUD(locked, bh.range, bh.tof);

    drawBullets(now);

    // Apply vision post-processing to the scene before scope overlay
    applyVisionPost();

    drawScopeOverlay(now, locked);

    // end condition
    const remaining = chars.filter(c=>c.alive).length;
    if(remaining === 0){
      if(!tick._won){
        tick._won = true;
        toast(`All targets cleared. Accuracy: <b>${shots ? Math.round((hits/shots)*100) : 0}%</b>`, 2600);
      }
    } else tick._won = false;

    // update wind UI every frame
    uiWind.textContent = `${effectiveWindSpeed().toFixed(1)} kt`;

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Start missions
  function init(){
    buildMissions();
    renderMissionUI();
    updateHUD(null, 0, 0);
    toast(`Wind is <b>${effectiveWindSpeed().toFixed(1)} kt</b>. Use lead dot for drift.`);
    toast(`Vision <b>N</b>. Breath-hold <b>Shift</b>. Zoom <b>Z</b>. Gusts will test you.`, 2400);
  }
  init();

})();
</script>
</body>
</html>
